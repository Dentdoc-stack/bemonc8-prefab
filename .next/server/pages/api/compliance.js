"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/compliance";
exports.ids = ["pages/api/compliance"];
exports.modules = {

/***/ "dayjs":
/*!************************!*\
  !*** external "dayjs" ***!
  \************************/
/***/ ((module) => {

module.exports = require("dayjs");

/***/ }),

/***/ "dayjs/plugin/customParseFormat":
/*!*************************************************!*\
  !*** external "dayjs/plugin/customParseFormat" ***!
  \*************************************************/
/***/ ((module) => {

module.exports = require("dayjs/plugin/customParseFormat");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "xlsx":
/*!***********************!*\
  !*** external "xlsx" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("xlsx");

/***/ }),

/***/ "zod":
/*!**********************!*\
  !*** external "zod" ***!
  \**********************/
/***/ ((module) => {

module.exports = import("zod");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcompliance&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fcompliance.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcompliance&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fcompliance.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pages/api/compliance.ts */ \"(api)/./src/pages/api/compliance.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/compliance\",\n        pathname: \"/api/compliance\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _src_pages_api_compliance_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNvbXBsaWFuY2UmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZzcmMlMkZwYWdlcyUyRmFwaSUyRmNvbXBsaWFuY2UudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDMEQ7QUFDMUQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHlEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyx5REFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG9vZGRhc2hib2FyZC8/OWNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vc3JjL3BhZ2VzL2FwaS9jb21wbGlhbmNlLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvY29tcGxpYW5jZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2NvbXBsaWFuY2VcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcompliance&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fcompliance.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./src/lib/backend/cache.ts":
/*!**********************************!*\
  !*** ./src/lib/backend/cache.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataCache: () => (/* binding */ dataCache)\n/* harmony export */ });\n/* harmony import */ var _data_ingestion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-ingestion */ \"(api)/./src/lib/backend/data-ingestion.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"(api)/./src/lib/backend/config.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_data_ingestion__WEBPACK_IMPORTED_MODULE_0__]);\n_data_ingestion__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Data Cache Layer\n * Manages in-memory cache with 30-minute auto-refresh\n */ \n\nclass DataCache {\n    /**\n     * Initialize cache and start auto-refresh\n     */ async initialize() {\n        console.log(\"Initializing data cache...\");\n        await this.refresh();\n        this.startAutoRefresh();\n    }\n    /**\n     * Refresh data from Google Sheets\n     */ async refresh() {\n        if (this.isRefreshing) {\n            console.warn(\"Refresh already in progress, skipping...\");\n            if (this.data) return this.data;\n            // Wait for ongoing refresh\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            return this.data;\n        }\n        this.isRefreshing = true;\n        try {\n            console.log(\"Refreshing cache from Google Sheets...\");\n            const newData = await (0,_data_ingestion__WEBPACK_IMPORTED_MODULE_0__.ingestAllSheets)();\n            this.data = newData;\n            console.log(`✅ Cache refreshed successfully at ${newData.lastRefresh.toISOString()}`);\n            return newData;\n        } catch (error) {\n            console.error(\"❌ Cache refresh failed:\", error);\n            if (!this.data) {\n                throw new Error(\"Cache refresh failed and no cached data available\");\n            }\n            // Return stale data if refresh fails\n            console.warn(\"Returning stale data due to refresh failure\");\n            return this.data;\n        } finally{\n            this.isRefreshing = false;\n        }\n    }\n    /**\n     * Start automatic refresh every 30 minutes\n     */ startAutoRefresh() {\n        if (this.refreshTimer) {\n            clearInterval(this.refreshTimer);\n        }\n        this.refreshTimer = setInterval(async ()=>{\n            console.log(\"Auto-refresh triggered\");\n            await this.refresh();\n        }, _config__WEBPACK_IMPORTED_MODULE_1__.CONFIG.cacheIntervalMs);\n        console.log(`Auto-refresh enabled (interval: ${_config__WEBPACK_IMPORTED_MODULE_1__.CONFIG.cacheIntervalMs / 1000}s)`);\n    }\n    /**\n     * Get all tasks\n     */ getTasks() {\n        if (!this.data) {\n            throw new Error(\"Cache not initialized\");\n        }\n        return this.data.tasks;\n    }\n    /**\n     * Get all sites\n     */ getSites() {\n        if (!this.data) {\n            throw new Error(\"Cache not initialized\");\n        }\n        return this.data.sites;\n    }\n    /**\n     * Get filtered sites\n     */ getFilteredSites(filters) {\n        let sites = this.getSites();\n        if (filters.packageId) {\n            sites = sites.filter((s)=>s.package_id === filters.packageId);\n        }\n        if (filters.district) {\n            sites = sites.filter((s)=>s.district === filters.district);\n        }\n        return sites;\n    }\n    /**\n     * Get tasks for a specific site\n     */ getTasksBySite(siteUid) {\n        return this.getTasks().filter((t)=>t.site_uid === siteUid);\n    }\n    /**\n     * Get full ingested data\n     */ getData() {\n        if (!this.data) {\n            throw new Error(\"Cache not initialized\");\n        }\n        return this.data;\n    }\n    /**\n     * Get package compliance data\n     */ getPackageCompliance() {\n        if (!this.data) {\n            throw new Error(\"Cache not initialized\");\n        }\n        return this.data.packageCompliance;\n    }\n    /**\n     * Check if cache is initialized\n     */ isInitialized() {\n        return this.data !== null;\n    }\n    /**\n     * Stop auto-refresh\n     */ stopAutoRefresh() {\n        if (this.refreshTimer) {\n            clearInterval(this.refreshTimer);\n            this.refreshTimer = null;\n            console.log(\"Auto-refresh stopped\");\n        }\n    }\n    constructor(){\n        this.data = null;\n        this.refreshTimer = null;\n        this.isRefreshing = false;\n    }\n}\n// Singleton instance\nconst dataCache = new DataCache();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUtBLEVBQUVDLFFBQVEsS0FBS0Y7SUFDdEQ7SUFFQTs7S0FFQyxHQUNERyxVQUF3QjtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDNUIsSUFBSSxFQUFFO1lBQ1osTUFBTSxJQUFJUSxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUNSLElBQUk7SUFDcEI7SUFFQTs7S0FFQyxHQUNENkIsdUJBQTZDO1FBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUM3QixJQUFJLEVBQUU7WUFDWixNQUFNLElBQUlRLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ1IsSUFBSSxDQUFDOEIsaUJBQWlCO0lBQ3RDO0lBRUE7O0tBRUMsR0FDREMsZ0JBQXlCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDL0IsSUFBSSxLQUFLO0lBQ3pCO0lBRUE7O0tBRUMsR0FDRGdDLGtCQUF3QjtRQUNwQixJQUFJLElBQUksQ0FBQ3ZCLFlBQVksRUFBRTtZQUNuQkMsY0FBYyxJQUFJLENBQUNELFlBQVk7WUFDL0IsSUFBSSxDQUFDQSxZQUFZLEdBQUc7WUFDcEJmLFFBQVFDLEdBQUcsQ0FBQztRQUNoQjtJQUNKOzthQWpKUUssT0FBNEI7YUFDNUJTLGVBQXNDO2FBQ3RDWCxlQUFlOztBQWdKM0I7QUFFQSxxQkFBcUI7QUFDZCxNQUFNbUMsWUFBWSxJQUFJekMsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb29kZGFzaGJvYXJkLy4vc3JjL2xpYi9iYWNrZW5kL2NhY2hlLnRzPzBmZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIENhY2hlIExheWVyXG4gKiBNYW5hZ2VzIGluLW1lbW9yeSBjYWNoZSB3aXRoIDMwLW1pbnV0ZSBhdXRvLXJlZnJlc2hcbiAqL1xuXG5pbXBvcnQgeyBpbmdlc3RBbGxTaGVldHMsIHR5cGUgSW5nZXN0ZWREYXRhIH0gZnJvbSAnLi9kYXRhLWluZ2VzdGlvbic7XG5pbXBvcnQgeyBDT05GSUcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IFRhc2tXaXRoU3RhdHVzLCBTaXRlQWdncmVnYXRlLCBQYWNrYWdlQ29tcGxpYW5jZU1hcCB9IGZyb20gJ0AvdHlwZXMnO1xuXG5jbGFzcyBEYXRhQ2FjaGUge1xuICAgIHByaXZhdGUgZGF0YTogSW5nZXN0ZWREYXRhIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSByZWZyZXNoVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBpc1JlZnJlc2hpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY2FjaGUgYW5kIHN0YXJ0IGF1dG8tcmVmcmVzaFxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgZGF0YSBjYWNoZS4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaCBkYXRhIGZyb20gR29vZ2xlIFNoZWV0c1xuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2goKTogUHJvbWlzZTxJbmdlc3RlZERhdGE+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWZyZXNoaW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlZnJlc2ggYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcuLi4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEpIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBvbmdvaW5nIHJlZnJlc2hcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhITtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgY2FjaGUgZnJvbSBHb29nbGUgU2hlZXRzLi4uJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdEYXRhID0gYXdhaXQgaW5nZXN0QWxsU2hlZXRzKCk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBDYWNoZSByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5IGF0ICR7bmV3RGF0YS5sYXN0UmVmcmVzaC50b0lTT1N0cmluZygpfWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQ2FjaGUgcmVmcmVzaCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIHJlZnJlc2ggZmFpbGVkIGFuZCBubyBjYWNoZWQgZGF0YSBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBzdGFsZSBkYXRhIGlmIHJlZnJlc2ggZmFpbHNcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmV0dXJuaW5nIHN0YWxlIGRhdGEgZHVlIHRvIHJlZnJlc2ggZmFpbHVyZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhdXRvbWF0aWMgcmVmcmVzaCBldmVyeSAzMCBtaW51dGVzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGFydEF1dG9SZWZyZXNoKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWZyZXNoVGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQXV0by1yZWZyZXNoIHRyaWdnZXJlZCcpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sIENPTkZJRy5jYWNoZUludGVydmFsTXMpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBBdXRvLXJlZnJlc2ggZW5hYmxlZCAoaW50ZXJ2YWw6ICR7Q09ORklHLmNhY2hlSW50ZXJ2YWxNcyAvIDEwMDB9cylgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRhc2tzXG4gICAgICovXG4gICAgZ2V0VGFza3MoKTogVGFza1dpdGhTdGF0dXNbXSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudGFza3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzaXRlc1xuICAgICAqL1xuICAgIGdldFNpdGVzKCk6IFNpdGVBZ2dyZWdhdGVbXSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2l0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpbHRlcmVkIHNpdGVzXG4gICAgICovXG4gICAgZ2V0RmlsdGVyZWRTaXRlcyhmaWx0ZXJzOiB7XG4gICAgICAgIHBhY2thZ2VJZD86IHN0cmluZztcbiAgICAgICAgZGlzdHJpY3Q/OiBzdHJpbmc7XG4gICAgfSk6IFNpdGVBZ2dyZWdhdGVbXSB7XG4gICAgICAgIGxldCBzaXRlcyA9IHRoaXMuZ2V0U2l0ZXMoKTtcblxuICAgICAgICBpZiAoZmlsdGVycy5wYWNrYWdlSWQpIHtcbiAgICAgICAgICAgIHNpdGVzID0gc2l0ZXMuZmlsdGVyKHMgPT4gcy5wYWNrYWdlX2lkID09PSBmaWx0ZXJzLnBhY2thZ2VJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVycy5kaXN0cmljdCkge1xuICAgICAgICAgICAgc2l0ZXMgPSBzaXRlcy5maWx0ZXIocyA9PiBzLmRpc3RyaWN0ID09PSBmaWx0ZXJzLmRpc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGFza3MgZm9yIGEgc3BlY2lmaWMgc2l0ZVxuICAgICAqL1xuICAgIGdldFRhc2tzQnlTaXRlKHNpdGVVaWQ6IHN0cmluZyk6IFRhc2tXaXRoU3RhdHVzW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUYXNrcygpLmZpbHRlcih0ID0+IHQuc2l0ZV91aWQgPT09IHNpdGVVaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmdWxsIGluZ2VzdGVkIGRhdGFcbiAgICAgKi9cbiAgICBnZXREYXRhKCk6IEluZ2VzdGVkRGF0YSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHBhY2thZ2UgY29tcGxpYW5jZSBkYXRhXG4gICAgICovXG4gICAgZ2V0UGFja2FnZUNvbXBsaWFuY2UoKTogUGFja2FnZUNvbXBsaWFuY2VNYXAge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnBhY2thZ2VDb21wbGlhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGF1dG8tcmVmcmVzaFxuICAgICAqL1xuICAgIHN0b3BBdXRvUmVmcmVzaCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVmcmVzaFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdXRvLXJlZnJlc2ggc3RvcHBlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBkYXRhQ2FjaGUgPSBuZXcgRGF0YUNhY2hlKCk7XG4iXSwibmFtZXMiOlsiaW5nZXN0QWxsU2hlZXRzIiwiQ09ORklHIiwiRGF0YUNhY2hlIiwiaW5pdGlhbGl6ZSIsImNvbnNvbGUiLCJsb2ciLCJyZWZyZXNoIiwic3RhcnRBdXRvUmVmcmVzaCIsImlzUmVmcmVzaGluZyIsIndhcm4iLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibmV3RGF0YSIsImxhc3RSZWZyZXNoIiwidG9JU09TdHJpbmciLCJlcnJvciIsIkVycm9yIiwicmVmcmVzaFRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2FjaGVJbnRlcnZhbE1zIiwiZ2V0VGFza3MiLCJ0YXNrcyIsImdldFNpdGVzIiwic2l0ZXMiLCJnZXRGaWx0ZXJlZFNpdGVzIiwiZmlsdGVycyIsInBhY2thZ2VJZCIsImZpbHRlciIsInMiLCJwYWNrYWdlX2lkIiwiZGlzdHJpY3QiLCJnZXRUYXNrc0J5U2l0ZSIsInNpdGVVaWQiLCJ0Iiwic2l0ZV91aWQiLCJnZXREYXRhIiwiZ2V0UGFja2FnZUNvbXBsaWFuY2UiLCJwYWNrYWdlQ29tcGxpYW5jZSIsImlzSW5pdGlhbGl6ZWQiLCJzdG9wQXV0b1JlZnJlc2giLCJkYXRhQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/lib/backend/cache.ts\n");

/***/ }),

/***/ "(api)/./src/lib/backend/config.ts":
/*!***********************************!*\
  !*** ./src/lib/backend/config.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFIG: () => (/* binding */ CONFIG),\n/* harmony export */   SHEET_SOURCES: () => (/* binding */ SHEET_SOURCES)\n/* harmony export */ });\n/**\n * Data source configuration for Google Sheets ingestion\n */ const SHEET_SOURCES = [\n    {\n        packageId: \"FP1\",\n        packageName: \"Flood Package\",\n        sheetId: \"2PACX-1vT8ioVcUUv9VXS48-z6-gWirSNDjDZFx9CW0lhlJqF4W7XFBaRGZXrvtmh9OCnLtQOVjiJ5t9dooMXV\",\n        sheetUrl: \"https://docs.google.com/spreadsheets/d/e/2PACX-1vT8ioVcUUv9VXS48-z6-gWirSNDjDZFx9CW0lhlJqF4W7XFBaRGZXrvtmh9OCnLtQOVjiJ5t9dooMXV/pub?output=xlsx\",\n        publishedXlsxUrl: \"https://docs.google.com/spreadsheets/d/e/2PACX-1vT8ioVcUUv9VXS48-z6-gWirSNDjDZFx9CW0lhlJqF4W7XFBaRGZXrvtmh9OCnLtQOVjiJ5t9dooMXV/pub?output=xlsx\"\n    }\n];\nconst CONFIG = {\n    tabName: \"Data_Entry\",\n    range: \"A:AD\",\n    cacheIntervalMs: 30 * 60 * 1000,\n    apiKey: process.env.NEXT_PUBLIC_GOOGLE_SHEETS_API_KEY || \"\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvbGliL2JhY2tlbmQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FVTSxNQUFNQSxnQkFBK0I7SUFDeEM7UUFDSUMsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsVUFBVTtRQUNWQyxrQkFBa0I7SUFDdEI7Q0FDSCxDQUFDO0FBRUssTUFBTUMsU0FBUztJQUNsQkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLGlCQUFpQixLQUFLLEtBQUs7SUFDM0JDLFFBQVFDLFFBQVFDLEdBQUcsQ0FBQ0MsaUNBQWlDLElBQUk7QUFDN0QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb29kZGFzaGJvYXJkLy4vc3JjL2xpYi9iYWNrZW5kL2NvbmZpZy50cz80YWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGF0YSBzb3VyY2UgY29uZmlndXJhdGlvbiBmb3IgR29vZ2xlIFNoZWV0cyBpbmdlc3Rpb25cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWV0U291cmNlIHtcbiAgICBwYWNrYWdlSWQ6IHN0cmluZztcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nO1xuICAgIHNoZWV0SWQ6IHN0cmluZztcbiAgICBzaGVldFVybDogc3RyaW5nO1xuICAgIHB1Ymxpc2hlZFhsc3hVcmw6IHN0cmluZzsgLy8gRm9yIGRpcmVjdCBYTFNYIGFjY2VzcyB3aXRob3V0IEFQSSBrZXlcbn1cblxuZXhwb3J0IGNvbnN0IFNIRUVUX1NPVVJDRVM6IFNoZWV0U291cmNlW10gPSBbXG4gICAge1xuICAgICAgICBwYWNrYWdlSWQ6ICdGUDEnLFxuICAgICAgICBwYWNrYWdlTmFtZTogJ0Zsb29kIFBhY2thZ2UnLFxuICAgICAgICBzaGVldElkOiAnMlBBQ1gtMXZUOGlvVmNVVXY5VlhTNDgtejYtZ1dpclNORGpEWkZ4OUNXMGxobEpxRjRXN1hGQmFSR1pYcnZ0bWg5T0NuTHRRT1ZqaUo1dDlkb29NWFYnLFxuICAgICAgICBzaGVldFVybDogJ2h0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kL2UvMlBBQ1gtMXZUOGlvVmNVVXY5VlhTNDgtejYtZ1dpclNORGpEWkZ4OUNXMGxobEpxRjRXN1hGQmFSR1pYcnZ0bWg5T0NuTHRRT1ZqaUo1dDlkb29NWFYvcHViP291dHB1dD14bHN4JyxcbiAgICAgICAgcHVibGlzaGVkWGxzeFVybDogJ2h0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kL2UvMlBBQ1gtMXZUOGlvVmNVVXY5VlhTNDgtejYtZ1dpclNORGpEWkZ4OUNXMGxobEpxRjRXN1hGQmFSR1pYcnZ0bWg5T0NuTHRRT1ZqaUo1dDlkb29NWFYvcHViP291dHB1dD14bHN4JyxcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IENPTkZJRyA9IHtcbiAgICB0YWJOYW1lOiAnRGF0YV9FbnRyeScsXG4gICAgcmFuZ2U6ICdBOkFEJyxcbiAgICBjYWNoZUludGVydmFsTXM6IDMwICogNjAgKiAxMDAwLCAvLyAzMCBtaW51dGVzXG4gICAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfU0hFRVRTX0FQSV9LRVkgfHwgJycsIC8vIE9wdGlvbmFsIGZvciBwdWJsaWMgc2hlZXRzXG59O1xuIl0sIm5hbWVzIjpbIlNIRUVUX1NPVVJDRVMiLCJwYWNrYWdlSWQiLCJwYWNrYWdlTmFtZSIsInNoZWV0SWQiLCJzaGVldFVybCIsInB1Ymxpc2hlZFhsc3hVcmwiLCJDT05GSUciLCJ0YWJOYW1lIiwicmFuZ2UiLCJjYWNoZUludGVydmFsTXMiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX1NIRUVUU19BUElfS0VZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/lib/backend/config.ts\n");

/***/ }),

/***/ "(api)/./src/lib/backend/data-ingestion.ts":
/*!*******************************************!*\
  !*** ./src/lib/backend/data-ingestion.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ingestAllSheets: () => (/* binding */ ingestAllSheets)\n/* harmony export */ });\n/* harmony import */ var _google_sheets_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./google-sheets-client */ \"(api)/./src/lib/backend/google-sheets-client.ts\");\n/* harmony import */ var _dataParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dataParser */ \"(api)/./src/lib/dataParser.ts\");\n/* harmony import */ var _dataProcessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dataProcessor */ \"(api)/./src/lib/dataProcessor.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"(api)/./src/lib/backend/config.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__, _dataParser__WEBPACK_IMPORTED_MODULE_1__]);\n([_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__, _dataParser__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Data Ingestion Module\n * Fetches Google Sheets, processes tasks with status computation, deduplicates\n */ \n\n\n\n/**\n * Ingest all Google Sheets and process into structured data\n */ async function ingestAllSheets() {\n    console.log(\"=== STARTING DATA INGESTION ===\");\n    const startTime = Date.now();\n    // Step 1: Fetch all sheets and compliance data in parallel\n    const [sheetsData, complianceData, ipcData] = await Promise.all([\n        (0,_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__.fetchAllSheets)(),\n        (0,_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__.fetchAllComplianceData)(),\n        (0,_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__.fetchAllIPCData)()\n    ]);\n    // Convert compliance Map to Record\n    const packageCompliance = {};\n    complianceData.forEach((value, key)=>{\n        packageCompliance[key] = value;\n    });\n    // Step 2: Map to Task objects\n    const rawTasks = [];\n    let totalRawRows = 0;\n    for (const source of _config__WEBPACK_IMPORTED_MODULE_3__.SHEET_SOURCES){\n        const rows = sheetsData.get(source.packageId) || [];\n        totalRawRows += rows.length;\n        rows.forEach((row)=>{\n            const task = (0,_google_sheets_client__WEBPACK_IMPORTED_MODULE_0__.mapRowToTask)(row, source.packageId, source.packageName);\n            if (task) {\n                rawTasks.push(task);\n            }\n        });\n    }\n    console.log(`Mapped ${rawTasks.length} tasks from ${totalRawRows} raw rows`);\n    // Step 3: Compute status for each task (adds derived fields)\n    const tasksWithStatus = rawTasks.map((task)=>(0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.computeTaskStatus)(task));\n    // Step 4: Deduplicate by task_uid\n    const taskMap = new Map();\n    tasksWithStatus.forEach((task)=>{\n        if (!taskMap.has(task.task_uid)) {\n            taskMap.set(task.task_uid, task);\n        }\n    });\n    const tasks = Array.from(taskMap.values());\n    console.log(`Deduplicated to ${tasks.length} unique tasks`);\n    // Step 5: Aggregate to sites\n    const sites = (0,_dataProcessor__WEBPACK_IMPORTED_MODULE_2__.groupTasksBySite)(tasks);\n    console.log(`Aggregated into ${sites.length} sites`);\n    // Step 6: Compute KPIs\n    const kpis = (0,_dataProcessor__WEBPACK_IMPORTED_MODULE_2__.computeKPIs)(tasks);\n    // Step 7: Validate data integrity\n    validateDataIntegrity(tasks, sites, kpis);\n    // Log compliance summary\n    const compliantCount = Object.values(packageCompliance).filter((c)=>c.status === \"COMPLIANT\").length;\n    const nonCompliantCount = Object.values(packageCompliance).filter((c)=>c.status === \"NON_COMPLIANT\").length;\n    console.log(`Package compliance: ${compliantCount} compliant, ${nonCompliantCount} non-compliant`);\n    const endTime = Date.now();\n    console.log(`=== INGESTION COMPLETE (${endTime - startTime}ms) ===`);\n    return {\n        tasks,\n        sites,\n        kpis,\n        packageCompliance,\n        ipcData,\n        lastRefresh: new Date(),\n        source: \"google-sheets\",\n        _metadata: {\n            totalRawRows,\n            validTasks: tasks.length,\n            uniqueSites: sites.length,\n            packages: _config__WEBPACK_IMPORTED_MODULE_3__.SHEET_SOURCES.map((s)=>s.packageId)\n        }\n    };\n}\n/**\n * Validate data integrity - throw errors if assertions fail\n */ function validateDataIntegrity(tasks, sites, kpis) {\n    console.log(\"=== VALIDATING DATA INTEGRITY ===\");\n    // Assertion 1: Unique site count\n    const uniqueSiteUids = new Set(tasks.map((t)=>t.site_uid));\n    if (uniqueSiteUids.size !== sites.length) {\n        throw new Error(`Site count mismatch: ${uniqueSiteUids.size} unique site_uids but ${sites.length} aggregated sites`);\n    }\n    console.log(`✅ Site count: ${sites.length}`);\n    // Assertion 2: KPI totalSites matches\n    if (kpis.totalSites !== sites.length) {\n        throw new Error(`KPI site count mismatch: kpis.totalSites=${kpis.totalSites}, sites.length=${sites.length}`);\n    }\n    console.log(`✅ KPI totalSites matches: ${kpis.totalSites}`);\n    // Assertion 3: Site progress cannot be 100% unless all tasks complete\n    const invalidSites = sites.filter((site)=>{\n        if (site.weightedProgress >= 99.9) {\n            const allComplete = site.tasks.every((t)=>t.status === \"completed\");\n            return !allComplete;\n        }\n        return false;\n    });\n    if (invalidSites.length > 0) {\n        throw new Error(`Found ${invalidSites.length} site(s) with 100% progress but incomplete tasks: ${invalidSites.map((s)=>s.site_name).join(\", \")}`);\n    }\n    console.log(`✅ All 100% sites have all tasks completed`);\n    // Assertion 4: No negative progress\n    const negativeProgress = tasks.filter((t)=>(t.progress_pct ?? 0) < 0);\n    if (negativeProgress.length > 0) {\n        throw new Error(`Found ${negativeProgress.length} tasks with negative progress`);\n    }\n    console.log(`✅ No negative progress values`);\n    console.log(\"=== VALIDATION PASSED ===\");\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvbGliL2JhY2tlbmQvZGF0YS1pbmdlc3Rpb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFOEc7QUFDN0Q7QUFDZTtBQUN4QjtBQW1CekM7O0NBRUMsR0FDTSxlQUFlUTtJQUNsQkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1osTUFBTUMsWUFBWUMsS0FBS0MsR0FBRztJQUUxQiwyREFBMkQ7SUFDM0QsTUFBTSxDQUFDQyxZQUFZQyxnQkFBZ0JDLFFBQVEsR0FBRyxNQUFNQyxRQUFRQyxHQUFHLENBQUM7UUFDNURsQixxRUFBY0E7UUFDZEUsNkVBQXNCQTtRQUN0QkMsc0VBQWVBO0tBQ2xCO0lBRUQsbUNBQW1DO0lBQ25DLE1BQU1nQixvQkFBMEMsQ0FBQztJQUNqREosZUFBZUssT0FBTyxDQUFDLENBQUNDLE9BQU9DO1FBQzNCSCxpQkFBaUIsQ0FBQ0csSUFBSSxHQUFHRDtJQUM3QjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNRSxXQUFtQixFQUFFO0lBQzNCLElBQUlDLGVBQWU7SUFFbkIsS0FBSyxNQUFNQyxVQUFVbEIsa0RBQWFBLENBQUU7UUFDaEMsTUFBTW1CLE9BQU9aLFdBQVdhLEdBQUcsQ0FBQ0YsT0FBT0csU0FBUyxLQUFLLEVBQUU7UUFDbkRKLGdCQUFnQkUsS0FBS0csTUFBTTtRQUUzQkgsS0FBS04sT0FBTyxDQUFDVSxDQUFBQTtZQUNULE1BQU1DLE9BQU85QixtRUFBWUEsQ0FBQzZCLEtBQUtMLE9BQU9HLFNBQVMsRUFBRUgsT0FBT08sV0FBVztZQUNuRSxJQUFJRCxNQUFNO2dCQUNOUixTQUFTVSxJQUFJLENBQUNGO1lBQ2xCO1FBQ0o7SUFDSjtJQUVBdEIsUUFBUUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFYSxTQUFTTSxNQUFNLENBQUMsWUFBWSxFQUFFTCxhQUFhLFNBQVMsQ0FBQztJQUUzRSw2REFBNkQ7SUFDN0QsTUFBTVUsa0JBQWtCWCxTQUFTWSxHQUFHLENBQUNKLENBQUFBLE9BQVEzQiw4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Z0IsSUFBSSxNQUFNO1lBQy9CLE1BQU1DLGNBQWNGLEtBQUs1QixLQUFLLENBQUMrQixLQUFLLENBQUNULENBQUFBLElBQUtBLEVBQUVYLE1BQU0sS0FBSztZQUN2RCxPQUFPLENBQUNtQjtRQUNaO1FBQ0EsT0FBTztJQUNYO0lBRUEsSUFBSUgsYUFBYXZDLE1BQU0sR0FBRyxHQUFHO1FBQ3pCLE1BQU0sSUFBSXFDLE1BQ04sQ0FBQyxNQUFNLEVBQUVFLGFBQWF2QyxNQUFNLENBQUMsa0RBQWtELEVBQUV1QyxhQUFhakMsR0FBRyxDQUFDeUIsQ0FBQUEsSUFBS0EsRUFBRWEsU0FBUyxFQUFFQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBRXhJO0lBQ0FqRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyx5Q0FBeUMsQ0FBQztJQUV2RCxvQ0FBb0M7SUFDcEMsTUFBTWlFLG1CQUFtQmxDLE1BQU1TLE1BQU0sQ0FBQ2EsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFYSxZQUFZLElBQUksS0FBSztJQUNuRSxJQUFJRCxpQkFBaUI5QyxNQUFNLEdBQUcsR0FBRztRQUM3QixNQUFNLElBQUlxQyxNQUFNLENBQUMsTUFBTSxFQUFFUyxpQkFBaUI5QyxNQUFNLENBQUMsNkJBQTZCLENBQUM7SUFDbkY7SUFDQXBCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixDQUFDO0lBRTNDRCxRQUFRQyxHQUFHLENBQUM7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG9vZGRhc2hib2FyZC8uL3NyYy9saWIvYmFja2VuZC9kYXRhLWluZ2VzdGlvbi50cz9kYmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGF0YSBJbmdlc3Rpb24gTW9kdWxlXG4gKiBGZXRjaGVzIEdvb2dsZSBTaGVldHMsIHByb2Nlc3NlcyB0YXNrcyB3aXRoIHN0YXR1cyBjb21wdXRhdGlvbiwgZGVkdXBsaWNhdGVzXG4gKi9cblxuaW1wb3J0IHsgZmV0Y2hBbGxTaGVldHMsIG1hcFJvd1RvVGFzaywgZmV0Y2hBbGxDb21wbGlhbmNlRGF0YSwgZmV0Y2hBbGxJUENEYXRhIH0gZnJvbSAnLi9nb29nbGUtc2hlZXRzLWNsaWVudCc7XG5pbXBvcnQgeyBjb21wdXRlVGFza1N0YXR1cyB9IGZyb20gJy4uL2RhdGFQYXJzZXInO1xuaW1wb3J0IHsgZ3JvdXBUYXNrc0J5U2l0ZSwgY29tcHV0ZUtQSXMgfSBmcm9tICcuLi9kYXRhUHJvY2Vzc29yJztcbmltcG9ydCB7IFNIRUVUX1NPVVJDRVMgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IFRhc2ssIFRhc2tXaXRoU3RhdHVzLCBTaXRlQWdncmVnYXRlLCBEYXNoYm9hcmRLUElzLCBQYWNrYWdlQ29tcGxpYW5jZU1hcCwgSVBDRGF0YSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZ2VzdGVkRGF0YSB7XG4gICAgdGFza3M6IFRhc2tXaXRoU3RhdHVzW107XG4gICAgc2l0ZXM6IFNpdGVBZ2dyZWdhdGVbXTtcbiAgICBrcGlzOiBEYXNoYm9hcmRLUElzO1xuICAgIHBhY2thZ2VDb21wbGlhbmNlOiBQYWNrYWdlQ29tcGxpYW5jZU1hcDtcbiAgICBpcGNEYXRhOiBJUENEYXRhO1xuICAgIGxhc3RSZWZyZXNoOiBEYXRlO1xuICAgIHNvdXJjZTogJ2dvb2dsZS1zaGVldHMnO1xuICAgIF9tZXRhZGF0YToge1xuICAgICAgICB0b3RhbFJhd1Jvd3M6IG51bWJlcjtcbiAgICAgICAgdmFsaWRUYXNrczogbnVtYmVyO1xuICAgICAgICB1bmlxdWVTaXRlczogbnVtYmVyO1xuICAgICAgICBwYWNrYWdlczogc3RyaW5nW107XG4gICAgfTtcbn1cblxuLyoqXG4gKiBJbmdlc3QgYWxsIEdvb2dsZSBTaGVldHMgYW5kIHByb2Nlc3MgaW50byBzdHJ1Y3R1cmVkIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdEFsbFNoZWV0cygpOiBQcm9taXNlPEluZ2VzdGVkRGF0YT4ge1xuICAgIGNvbnNvbGUubG9nKCc9PT0gU1RBUlRJTkcgREFUQSBJTkdFU1RJT04gPT09Jyk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFN0ZXAgMTogRmV0Y2ggYWxsIHNoZWV0cyBhbmQgY29tcGxpYW5jZSBkYXRhIGluIHBhcmFsbGVsXG4gICAgY29uc3QgW3NoZWV0c0RhdGEsIGNvbXBsaWFuY2VEYXRhLCBpcGNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZmV0Y2hBbGxTaGVldHMoKSxcbiAgICAgICAgZmV0Y2hBbGxDb21wbGlhbmNlRGF0YSgpLFxuICAgICAgICBmZXRjaEFsbElQQ0RhdGEoKSxcbiAgICBdKTtcblxuICAgIC8vIENvbnZlcnQgY29tcGxpYW5jZSBNYXAgdG8gUmVjb3JkXG4gICAgY29uc3QgcGFja2FnZUNvbXBsaWFuY2U6IFBhY2thZ2VDb21wbGlhbmNlTWFwID0ge307XG4gICAgY29tcGxpYW5jZURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBwYWNrYWdlQ29tcGxpYW5jZVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBTdGVwIDI6IE1hcCB0byBUYXNrIG9iamVjdHNcbiAgICBjb25zdCByYXdUYXNrczogVGFza1tdID0gW107XG4gICAgbGV0IHRvdGFsUmF3Um93cyA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBTSEVFVF9TT1VSQ0VTKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBzaGVldHNEYXRhLmdldChzb3VyY2UucGFja2FnZUlkKSB8fCBbXTtcbiAgICAgICAgdG90YWxSYXdSb3dzICs9IHJvd3MubGVuZ3RoO1xuXG4gICAgICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IG1hcFJvd1RvVGFzayhyb3csIHNvdXJjZS5wYWNrYWdlSWQsIHNvdXJjZS5wYWNrYWdlTmFtZSk7XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHJhd1Rhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBNYXBwZWQgJHtyYXdUYXNrcy5sZW5ndGh9IHRhc2tzIGZyb20gJHt0b3RhbFJhd1Jvd3N9IHJhdyByb3dzYCk7XG5cbiAgICAvLyBTdGVwIDM6IENvbXB1dGUgc3RhdHVzIGZvciBlYWNoIHRhc2sgKGFkZHMgZGVyaXZlZCBmaWVsZHMpXG4gICAgY29uc3QgdGFza3NXaXRoU3RhdHVzID0gcmF3VGFza3MubWFwKHRhc2sgPT4gY29tcHV0ZVRhc2tTdGF0dXModGFzaykpO1xuXG4gICAgLy8gU3RlcCA0OiBEZWR1cGxpY2F0ZSBieSB0YXNrX3VpZFxuICAgIGNvbnN0IHRhc2tNYXAgPSBuZXcgTWFwPHN0cmluZywgVGFza1dpdGhTdGF0dXM+KCk7XG4gICAgdGFza3NXaXRoU3RhdHVzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFza01hcC5oYXModGFzay50YXNrX3VpZCkpIHtcbiAgICAgICAgICAgIHRhc2tNYXAuc2V0KHRhc2sudGFza191aWQsIHRhc2spO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB0YXNrcyA9IEFycmF5LmZyb20odGFza01hcC52YWx1ZXMoKSk7XG4gICAgY29uc29sZS5sb2coYERlZHVwbGljYXRlZCB0byAke3Rhc2tzLmxlbmd0aH0gdW5pcXVlIHRhc2tzYCk7XG5cbiAgICAvLyBTdGVwIDU6IEFnZ3JlZ2F0ZSB0byBzaXRlc1xuICAgIGNvbnN0IHNpdGVzID0gZ3JvdXBUYXNrc0J5U2l0ZSh0YXNrcyk7XG4gICAgY29uc29sZS5sb2coYEFnZ3JlZ2F0ZWQgaW50byAke3NpdGVzLmxlbmd0aH0gc2l0ZXNgKTtcblxuICAgIC8vIFN0ZXAgNjogQ29tcHV0ZSBLUElzXG4gICAgY29uc3Qga3BpcyA9IGNvbXB1dGVLUElzKHRhc2tzKTtcblxuICAgIC8vIFN0ZXAgNzogVmFsaWRhdGUgZGF0YSBpbnRlZ3JpdHlcbiAgICB2YWxpZGF0ZURhdGFJbnRlZ3JpdHkodGFza3MsIHNpdGVzLCBrcGlzKTtcblxuICAgIC8vIExvZyBjb21wbGlhbmNlIHN1bW1hcnlcbiAgICBjb25zdCBjb21wbGlhbnRDb3VudCA9IE9iamVjdC52YWx1ZXMocGFja2FnZUNvbXBsaWFuY2UpLmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnQ09NUExJQU5UJykubGVuZ3RoO1xuICAgIGNvbnN0IG5vbkNvbXBsaWFudENvdW50ID0gT2JqZWN0LnZhbHVlcyhwYWNrYWdlQ29tcGxpYW5jZSkuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdOT05fQ09NUExJQU5UJykubGVuZ3RoO1xuICAgIGNvbnNvbGUubG9nKGBQYWNrYWdlIGNvbXBsaWFuY2U6ICR7Y29tcGxpYW50Q291bnR9IGNvbXBsaWFudCwgJHtub25Db21wbGlhbnRDb3VudH0gbm9uLWNvbXBsaWFudGApO1xuXG4gICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coYD09PSBJTkdFU1RJT04gQ09NUExFVEUgKCR7ZW5kVGltZSAtIHN0YXJ0VGltZX1tcykgPT09YCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXNrcyxcbiAgICAgICAgc2l0ZXMsXG4gICAgICAgIGtwaXMsXG4gICAgICAgIHBhY2thZ2VDb21wbGlhbmNlLFxuICAgICAgICBpcGNEYXRhLFxuICAgICAgICBsYXN0UmVmcmVzaDogbmV3IERhdGUoKSxcbiAgICAgICAgc291cmNlOiAnZ29vZ2xlLXNoZWV0cycsXG4gICAgICAgIF9tZXRhZGF0YToge1xuICAgICAgICAgICAgdG90YWxSYXdSb3dzLFxuICAgICAgICAgICAgdmFsaWRUYXNrczogdGFza3MubGVuZ3RoLFxuICAgICAgICAgICAgdW5pcXVlU2l0ZXM6IHNpdGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHBhY2thZ2VzOiBTSEVFVF9TT1VSQ0VTLm1hcChzID0+IHMucGFja2FnZUlkKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGRhdGEgaW50ZWdyaXR5IC0gdGhyb3cgZXJyb3JzIGlmIGFzc2VydGlvbnMgZmFpbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGFJbnRlZ3JpdHkoXG4gICAgdGFza3M6IFRhc2tXaXRoU3RhdHVzW10sXG4gICAgc2l0ZXM6IFNpdGVBZ2dyZWdhdGVbXSxcbiAgICBrcGlzOiBEYXNoYm9hcmRLUElzXG4pIHtcbiAgICBjb25zb2xlLmxvZygnPT09IFZBTElEQVRJTkcgREFUQSBJTlRFR1JJVFkgPT09Jyk7XG5cbiAgICAvLyBBc3NlcnRpb24gMTogVW5pcXVlIHNpdGUgY291bnRcbiAgICBjb25zdCB1bmlxdWVTaXRlVWlkcyA9IG5ldyBTZXQodGFza3MubWFwKHQgPT4gdC5zaXRlX3VpZCkpO1xuICAgIGlmICh1bmlxdWVTaXRlVWlkcy5zaXplICE9PSBzaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFNpdGUgY291bnQgbWlzbWF0Y2g6ICR7dW5pcXVlU2l0ZVVpZHMuc2l6ZX0gdW5pcXVlIHNpdGVfdWlkcyBidXQgJHtzaXRlcy5sZW5ndGh9IGFnZ3JlZ2F0ZWQgc2l0ZXNgXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGDinIUgU2l0ZSBjb3VudDogJHtzaXRlcy5sZW5ndGh9YCk7XG5cbiAgICAvLyBBc3NlcnRpb24gMjogS1BJIHRvdGFsU2l0ZXMgbWF0Y2hlc1xuICAgIGlmIChrcGlzLnRvdGFsU2l0ZXMgIT09IHNpdGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgS1BJIHNpdGUgY291bnQgbWlzbWF0Y2g6IGtwaXMudG90YWxTaXRlcz0ke2twaXMudG90YWxTaXRlc30sIHNpdGVzLmxlbmd0aD0ke3NpdGVzLmxlbmd0aH1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGDinIUgS1BJIHRvdGFsU2l0ZXMgbWF0Y2hlczogJHtrcGlzLnRvdGFsU2l0ZXN9YCk7XG5cbiAgICAvLyBBc3NlcnRpb24gMzogU2l0ZSBwcm9ncmVzcyBjYW5ub3QgYmUgMTAwJSB1bmxlc3MgYWxsIHRhc2tzIGNvbXBsZXRlXG4gICAgY29uc3QgaW52YWxpZFNpdGVzID0gc2l0ZXMuZmlsdGVyKHNpdGUgPT4ge1xuICAgICAgICBpZiAoc2l0ZS53ZWlnaHRlZFByb2dyZXNzID49IDk5LjkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbENvbXBsZXRlID0gc2l0ZS50YXNrcy5ldmVyeSh0ID0+IHQuc3RhdHVzID09PSAnY29tcGxldGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gIWFsbENvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmIChpbnZhbGlkU2l0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRm91bmQgJHtpbnZhbGlkU2l0ZXMubGVuZ3RofSBzaXRlKHMpIHdpdGggMTAwJSBwcm9ncmVzcyBidXQgaW5jb21wbGV0ZSB0YXNrczogJHtpbnZhbGlkU2l0ZXMubWFwKHMgPT4gcy5zaXRlX25hbWUpLmpvaW4oJywgJyl9YFxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhg4pyFIEFsbCAxMDAlIHNpdGVzIGhhdmUgYWxsIHRhc2tzIGNvbXBsZXRlZGApO1xuXG4gICAgLy8gQXNzZXJ0aW9uIDQ6IE5vIG5lZ2F0aXZlIHByb2dyZXNzXG4gICAgY29uc3QgbmVnYXRpdmVQcm9ncmVzcyA9IHRhc2tzLmZpbHRlcih0ID0+ICh0LnByb2dyZXNzX3BjdCA/PyAwKSA8IDApO1xuICAgIGlmIChuZWdhdGl2ZVByb2dyZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAke25lZ2F0aXZlUHJvZ3Jlc3MubGVuZ3RofSB0YXNrcyB3aXRoIG5lZ2F0aXZlIHByb2dyZXNzYCk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGDinIUgTm8gbmVnYXRpdmUgcHJvZ3Jlc3MgdmFsdWVzYCk7XG5cbiAgICBjb25zb2xlLmxvZygnPT09IFZBTElEQVRJT04gUEFTU0VEID09PScpO1xufVxuIl0sIm5hbWVzIjpbImZldGNoQWxsU2hlZXRzIiwibWFwUm93VG9UYXNrIiwiZmV0Y2hBbGxDb21wbGlhbmNlRGF0YSIsImZldGNoQWxsSVBDRGF0YSIsImNvbXB1dGVUYXNrU3RhdHVzIiwiZ3JvdXBUYXNrc0J5U2l0ZSIsImNvbXB1dGVLUElzIiwiU0hFRVRfU09VUkNFUyIsImluZ2VzdEFsbFNoZWV0cyIsImNvbnNvbGUiLCJsb2ciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93Iiwic2hlZXRzRGF0YSIsImNvbXBsaWFuY2VEYXRhIiwiaXBjRGF0YSIsIlByb21pc2UiLCJhbGwiLCJwYWNrYWdlQ29tcGxpYW5jZSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInJhd1Rhc2tzIiwidG90YWxSYXdSb3dzIiwic291cmNlIiwicm93cyIsImdldCIsInBhY2thZ2VJZCIsImxlbmd0aCIsInJvdyIsInRhc2siLCJwYWNrYWdlTmFtZSIsInB1c2giLCJ0YXNrc1dpdGhTdGF0dXMiLCJtYXAiLCJ0YXNrTWFwIiwiTWFwIiwiaGFzIiwidGFza191aWQiLCJzZXQiLCJ0YXNrcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNpdGVzIiwia3BpcyIsInZhbGlkYXRlRGF0YUludGVncml0eSIsImNvbXBsaWFudENvdW50IiwiT2JqZWN0IiwiZmlsdGVyIiwiYyIsInN0YXR1cyIsIm5vbkNvbXBsaWFudENvdW50IiwiZW5kVGltZSIsImxhc3RSZWZyZXNoIiwiX21ldGFkYXRhIiwidmFsaWRUYXNrcyIsInVuaXF1ZVNpdGVzIiwicGFja2FnZXMiLCJzIiwidW5pcXVlU2l0ZVVpZHMiLCJTZXQiLCJ0Iiwic2l0ZV91aWQiLCJzaXplIiwiRXJyb3IiLCJ0b3RhbFNpdGVzIiwiaW52YWxpZFNpdGVzIiwic2l0ZSIsIndlaWdodGVkUHJvZ3Jlc3MiLCJhbGxDb21wbGV0ZSIsImV2ZXJ5Iiwic2l0ZV9uYW1lIiwiam9pbiIsIm5lZ2F0aXZlUHJvZ3Jlc3MiLCJwcm9ncmVzc19wY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/lib/backend/data-ingestion.ts\n");

/***/ }),

/***/ "(api)/./src/lib/backend/google-sheets-client.ts":
/*!*************************************************!*\
  !*** ./src/lib/backend/google-sheets-client.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchAllComplianceData: () => (/* binding */ fetchAllComplianceData),\n/* harmony export */   fetchAllIPCData: () => (/* binding */ fetchAllIPCData),\n/* harmony export */   fetchAllSheets: () => (/* binding */ fetchAllSheets),\n/* harmony export */   mapRowToTask: () => (/* binding */ mapRowToTask)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(api)/./src/lib/backend/config.ts\");\n/* harmony import */ var _dataParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dataParser */ \"(api)/./src/lib/dataParser.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dataParser__WEBPACK_IMPORTED_MODULE_1__]);\n_dataParser__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Google Sheets Client - Fetches published XLSX files directly\n */ \n\n/**\n * Parse raw compliance data into PackageCompliance with status logic\n */ function parseComplianceData(raw) {\n    if (!raw) {\n        return {\n            no_of_staff_rfb: null,\n            cesmps_submitted: null,\n            ohs_measures: null,\n            status: \"UNKNOWN\",\n            issues: [\n                \"Compliance data not available\"\n            ]\n        };\n    }\n    // Parse Yes/No fields (all three are Yes/No format)\n    const parseYesNo = (val)=>{\n        if (!val && val !== 0) return null;\n        const normalized = String(val).toLowerCase().trim();\n        if (normalized === \"yes\") return \"Yes\";\n        if (normalized === \"no\") return \"No\";\n        return null;\n    };\n    const staffRfb = parseYesNo(raw.no_of_staff_rfb);\n    const cesmps = parseYesNo(raw.cesmps_submitted);\n    const ohs = parseYesNo(raw.ohs_measures);\n    // Determine status and issues\n    const issues = [];\n    const allBlank = staffRfb === null && cesmps === null && ohs === null;\n    if (allBlank) {\n        return {\n            no_of_staff_rfb: staffRfb,\n            cesmps_submitted: cesmps,\n            ohs_measures: ohs,\n            status: \"UNKNOWN\",\n            issues: [\n                \"All compliance fields are blank\"\n            ]\n        };\n    }\n    // Check each field for compliance issues\n    if (staffRfb !== \"Yes\") {\n        issues.push(staffRfb === null ? \"Staff RFB status unknown\" : \"Staff RFB not submitted\");\n    }\n    if (cesmps !== \"Yes\") {\n        issues.push(cesmps === null ? \"CESMPS submission status unknown\" : \"CESMPS not submitted\");\n    }\n    if (ohs !== \"Yes\") {\n        issues.push(ohs === null ? \"OHS measures status unknown\" : \"OHS measures not in place\");\n    }\n    const status = issues.length === 0 ? \"COMPLIANT\" : \"NON_COMPLIANT\";\n    return {\n        no_of_staff_rfb: staffRfb,\n        cesmps_submitted: cesmps,\n        ohs_measures: ohs,\n        status,\n        issues\n    };\n}\n/**\n * Extract compliance data from published XLSX files\n * Reads row 2 (columns V, W, X) for compliance metadata\n */ async function fetchAllComplianceData() {\n    console.log(\"Extracting compliance data from published XLSX files...\");\n    const complianceMap = new Map();\n    const results = await Promise.allSettled(_config__WEBPACK_IMPORTED_MODULE_0__.SHEET_SOURCES.map(async (source)=>{\n        try {\n            console.log(`📋 Fetching compliance for ${source.packageId}...`);\n            const response = await fetch(source.publishedXlsxUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch XLSX: ${response.statusText}`);\n            }\n            const arrayBuffer = await response.arrayBuffer();\n            const data = new Uint8Array(arrayBuffer);\n            // Import XLSX dynamically\n            const XLSX = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! xlsx */ \"xlsx\", 23));\n            const workbook = XLSX.read(data, {\n                type: \"array\",\n                cellDates: true\n            });\n            // Find Data_Entry sheet\n            let sheetName = \"Data_Entry\";\n            if (!workbook.SheetNames.includes(sheetName)) {\n                sheetName = workbook.SheetNames[0];\n            }\n            const worksheet = workbook.Sheets[sheetName];\n            const jsonRows = XLSX.utils.sheet_to_json(worksheet, {\n                raw: false,\n                defval: null\n            });\n            // Debug: log first row to see all columns\n            console.log(`📋 ${source.packageId} - Total rows: ${jsonRows.length}`);\n            if (jsonRows.length > 0) {\n                console.log(`📋 ${source.packageId} - Row 1 columns:`, Object.keys(jsonRows[0]));\n                console.log(`📋 ${source.packageId} - Row 1 data:`, jsonRows[0]);\n            }\n            // Row 2 is at index 0 (since sheet_to_json skips headers)\n            if (jsonRows.length > 0) {\n                const row = jsonRows[0];\n                // Try to find columns with different possible names\n                const staffRfbNames = [\n                    \"No_of_Staff_RFB\",\n                    \"No of Staff RFB\",\n                    \"Staff RFB\",\n                    \"No_of_Staff_RFB\"\n                ];\n                const cesmpNames = [\n                    \"CESMPS_Submitted\",\n                    \"CESMPS_Submitte\",\n                    \"CEMSPS_Submitted\",\n                    \"CESMPS\"\n                ];\n                const ohsNames = [\n                    \"OHS_Measures\",\n                    \"OHS Measures\",\n                    \"OHS\",\n                    \"OHS_Measures\"\n                ];\n                let staffValue = null;\n                let cesmpsValue = null;\n                let ohsValue = null;\n                // Search for each column\n                for (const colName of staffRfbNames){\n                    if (colName in row && row[colName] !== null && row[colName] !== undefined && row[colName] !== \"\") {\n                        staffValue = row[colName];\n                        console.log(`✅ ${source.packageId} - Found Staff RFB at \"${colName}\": ${staffValue}`);\n                        break;\n                    }\n                }\n                for (const colName of cesmpNames){\n                    if (colName in row && row[colName] !== null && row[colName] !== undefined && row[colName] !== \"\") {\n                        cesmpsValue = row[colName];\n                        console.log(`✅ ${source.packageId} - Found CESMPS at \"${colName}\": ${cesmpsValue}`);\n                        break;\n                    }\n                }\n                for (const colName of ohsNames){\n                    if (colName in row && row[colName] !== null && row[colName] !== undefined && row[colName] !== \"\") {\n                        ohsValue = row[colName];\n                        console.log(`✅ ${source.packageId} - Found OHS at \"${colName}\": ${ohsValue}`);\n                        break;\n                    }\n                }\n                const rawData = {\n                    no_of_staff_rfb: staffValue,\n                    cesmps_submitted: cesmpsValue?.toString() ?? null,\n                    ohs_measures: ohsValue?.toString() ?? null\n                };\n                console.log(`📋 ${source.packageId} - Final raw data:`, rawData);\n                const compliance = parseComplianceData(rawData);\n                return {\n                    packageId: source.packageId,\n                    compliance\n                };\n            } else {\n                console.warn(`⚠️ No row 1 data found for ${source.packageId}`);\n                return {\n                    packageId: source.packageId,\n                    compliance: parseComplianceData(null)\n                };\n            }\n        } catch (error) {\n            console.error(`Error extracting compliance for ${source.packageId}:`, error);\n            return {\n                packageId: source.packageId,\n                compliance: parseComplianceData(null)\n            };\n        }\n    }));\n    results.forEach((result)=>{\n        if (result.status === \"fulfilled\") {\n            const { packageId, compliance } = result.value;\n            complianceMap.set(packageId, compliance);\n            console.log(`✅ Compliance for ${packageId}: ${compliance.status}`);\n        }\n    });\n    return complianceMap;\n}\n/**\n * Parse IPC (Interim Payment Certificate) data from XLSX worksheet\n * Reads row 2, columns Y-AD (0-indexed columns 24-29)\n */ function parseIPCData(sheet, xlsxUtils) {\n    console.log(\"[IPCData] Starting to parse IPC data...\");\n    console.log(\"[IPCData] Sheet !ref:\", sheet[\"!ref\"]);\n    console.log(\"[IPCData] All sheet keys:\", Object.keys(sheet).filter((k)=>!k.startsWith(\"!\")).slice(0, 20));\n    const records = [];\n    const statusMap = {\n        \"not submitted\": \"not submitted\",\n        \"submitted\": \"submitted\",\n        \"in process\": \"in process\",\n        \"released\": \"released\"\n    };\n    // Read columns 24-29 (Y-AD) from row 2 (index 1)\n    for(let col = 24; col <= 29; col++){\n        const cellRef = xlsxUtils.encode_cell({\n            r: 1,\n            c: col\n        });\n        const cellValue = sheet[cellRef];\n        console.log(`[IPCData] Reading Row 2, Column ${col} (${cellRef}):`, cellValue ? typeof cellValue === \"object\" && \"v\" in cellValue ? cellValue.v : cellValue : \"undefined\");\n        let statusRaw = null;\n        if (cellValue && typeof cellValue === \"object\" && \"v\" in cellValue && cellValue.v) {\n            statusRaw = String(cellValue.v).toLowerCase().trim();\n        }\n        const ipcNumber = `IPC ${col - 23}`; // IPC 1-6\n        const mappedStatus = statusRaw && statusRaw in statusMap ? statusMap[statusRaw] : null;\n        console.log(`[IPCData]   → IPC Number: ${ipcNumber}, Raw: \"${statusRaw}\", Mapped: \"${mappedStatus}\"`);\n        records.push({\n            ipcNumber,\n            status: mappedStatus\n        });\n    }\n    console.log(\"[IPCData] Final parsed records:\", records);\n    console.log(\"[IPCData] Non-null records:\", records.filter((r)=>r.status !== null).length);\n    return {\n        records\n    };\n}\n/**\n * Fetch IPC data from published XLSX\n * Extracts interim payment certificate statuses\n */ async function fetchAllIPCData() {\n    try {\n        console.log(\"[IPCData] Starting IPC data fetch...\");\n        if (_config__WEBPACK_IMPORTED_MODULE_0__.SHEET_SOURCES.length === 0) {\n            console.warn(\"[IPCData] No sheet sources configured\");\n            return {\n                records: []\n            };\n        }\n        const source = _config__WEBPACK_IMPORTED_MODULE_0__.SHEET_SOURCES[0];\n        console.log(`[IPCData] Fetching from ${source.packageId}: ${source.publishedXlsxUrl}`);\n        const response = await fetch(source.publishedXlsxUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch XLSX: ${response.statusText}`);\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        const data = new Uint8Array(arrayBuffer);\n        // Import XLSX dynamically\n        const XLSX = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! xlsx */ \"xlsx\", 23));\n        console.log(\"[IPCData] XLSX library loaded\");\n        const workbook = XLSX.read(data, {\n            type: \"array\",\n            cellDates: true\n        });\n        console.log(\"[IPCData] Workbook loaded, sheets:\", workbook.SheetNames);\n        // Find Data_Entry sheet\n        let sheetName = \"Data_Entry\";\n        if (!workbook.SheetNames.includes(sheetName)) {\n            sheetName = workbook.SheetNames[0];\n        }\n        const worksheet = workbook.Sheets[sheetName];\n        console.log(`[IPCData] Using sheet: ${sheetName}`);\n        const ipcData = parseIPCData(worksheet, XLSX.utils);\n        console.log(\"[IPCData] ✅ IPC data parsed successfully:\", ipcData);\n        return ipcData;\n    } catch (error) {\n        console.error(\"[IPCData] ❌ Error fetching IPC data:\", error);\n        return {\n            records: []\n        };\n    }\n}\n/**\n * Fetch all published sheets as XLSX and return raw rows for task parsing\n * Used for ingesting task data (not compliance - compliance is extracted separately)\n */ async function fetchAllSheets() {\n    console.log(\"Fetching published XLSX sheets for task data...\");\n    const results = await Promise.allSettled(_config__WEBPACK_IMPORTED_MODULE_0__.SHEET_SOURCES.map(async (source)=>{\n        try {\n            const response = await fetch(source.publishedXlsxUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch XLSX: ${response.statusText}`);\n            }\n            const arrayBuffer = await response.arrayBuffer();\n            const data = new Uint8Array(arrayBuffer);\n            const XLSX = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! xlsx */ \"xlsx\", 23));\n            const workbook = XLSX.read(data, {\n                type: \"array\",\n                cellDates: true\n            });\n            let sheetName = \"Data_Entry\";\n            if (!workbook.SheetNames.includes(sheetName)) {\n                sheetName = workbook.SheetNames[0];\n            }\n            const worksheet = workbook.Sheets[sheetName];\n            const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                raw: false,\n                defval: null\n            });\n            // Debug: log all available columns\n            console.log(`📋 ${source.packageId} - Total rows: ${jsonData.length}`);\n            if (jsonData.length > 0) {\n                console.log(`📋 ${source.packageId} - Column headers:`, Object.keys(jsonData[0]));\n                console.log(`📋 ${source.packageId} - Row 2 data:`, jsonData[0]);\n            }\n            return {\n                packageId: source.packageId,\n                rows: jsonData\n            };\n        } catch (error) {\n            console.error(`Error fetching sheet ${source.packageId}:`, error);\n            throw error;\n        }\n    }));\n    const dataMap = new Map();\n    results.forEach((result, index)=>{\n        const source = _config__WEBPACK_IMPORTED_MODULE_0__.SHEET_SOURCES[index];\n        if (result.status === \"fulfilled\") {\n            const { packageId, rows } = result.value;\n            dataMap.set(packageId, rows);\n            console.log(`✅ Fetched ${rows.length} rows from ${packageId}`);\n        } else {\n            console.error(`❌ Failed to fetch ${source.packageId}:`, result.reason);\n            dataMap.set(source.packageId, []);\n        }\n    });\n    return dataMap;\n}\n/**\n * Map raw sheet row to Task object\n */ function mapRowToTask(row, packageId, packageName) {\n    try {\n        // Skip empty rows\n        if (!row[\"Site ID\"] && !row[\"site_id\"]) {\n            return null;\n        }\n        // Handle both possible header formats\n        const getValue = (key1, key2)=>{\n            const val = row[key1] || row[key2];\n            return val ? String(val).trim() : \"\";\n        };\n        const getNumber = (key1, key2)=>{\n            const val = row[key1] || row[key2];\n            if (val === null || val === undefined || val === \"\") return null;\n            const num = Number(val);\n            return isNaN(num) ? null : num;\n        };\n        return {\n            package_id: packageId,\n            package_name: packageName,\n            district: getValue(\"District\", \"district\"),\n            site_id: getValue(\"Site ID\", \"site_id\"),\n            site_name: getValue(\"Site Name\", \"site_name\"),\n            discipline: getValue(\"Discipline\", \"discipline\"),\n            task_name: getValue(\"Task Name\", \"task_name\"),\n            planned_start: (0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.parseDMY)(getValue(\"Planned Start\", \"planned_start\")),\n            planned_finish: (0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.parseDMY)(getValue(\"Planned Finish\", \"planned_finish\")),\n            planned_duration_days: getNumber(\"Planned Duration (Days)\", \"planned_duration_days\"),\n            actual_start: (0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.parseDMY)(getValue(\"Actual Start\", \"actual_start\")),\n            actual_finish: (0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.parseDMY)(getValue(\"Actual Finish\", \"actual_finish\")),\n            progress_pct: getNumber(\"Progress %\", \"progress_pct\"),\n            Variance: getNumber(\"Variance\", \"Variance\"),\n            delay_flag_calc: getValue(\"Delay Flag\", \"delay_flag_calc\"),\n            last_updated: (0,_dataParser__WEBPACK_IMPORTED_MODULE_1__.parseDMY)(getValue(\"Last Updated\", \"last_updated\")),\n            remarks: getValue(\"Remarks\", \"remarks\"),\n            photo_folder_url: getValue(\"Photo Folder\", \"photo_folder_url\"),\n            cover_photo_share_url: getValue(\"Cover Photo\", \"cover_photo_share_url\"),\n            before_photo_share_url: getValue(\"Before Photo\", \"before_photo_share_url\"),\n            after_photo_share_url: getValue(\"After Photo\", \"after_photo_share_url\"),\n            cover_photo_direct_url: null,\n            before_photo_direct_url: null,\n            after_photo_direct_url: null\n        };\n    } catch (error) {\n        console.error(\"Error mapping row to task:\", error, row);\n        return null;\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvbGliL2JhY2tlbmQvZ29vZ2xlLXNoZWV0cy1jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFd0M7QUFFQTtBQVl6Qzs7Q0FFQyxHQUNELFNBQVNFLG9CQUFvQkMsR0FBNkI7SUFDdEQsSUFBSSxDQUFDQSxLQUFLO1FBQ04sT0FBTztZQUNIQyxpQkFBaUI7WUFDakJDLGtCQUFrQjtZQUNsQkMsY0FBYztZQUNkQyxRQUFRO1lBQ1JDLFFBQVE7Z0JBQUM7YUFBZ0M7UUFDN0M7SUFDSjtJQUVBLG9EQUFvRDtJQUNwRCxNQUFNQyxhQUFhLENBQUNDO1FBQ2hCLElBQUksQ0FBQ0EsT0FBT0EsUUFBUSxHQUFHLE9BQU87UUFDOUIsTUFBTUMsYUFBYUMsT0FBT0YsS0FBS0csV0FBVyxHQUFHQyxJQUFJO1FBQ2pELElBQUlILGVBQWUsT0FBTyxPQUFPO1FBQ2pDLElBQUlBLGVBQWUsTUFBTSxPQUFPO1FBQ2hDLE9BQU87SUFDWDtJQUVBLE1BQU1JLFdBQVdOLFdBQVdOLElBQUlDLGVBQWU7SUFDL0MsTUFBTVksU0FBU1AsV0FBV04sSUFBSUUsZ0JBQWdCO0lBQzlDLE1BQU1ZLE1BQU1SLFdBQVdOLElBQUlHLFlBQVk7SUFFdkMsOEJBQThCO0lBQzlCLE1BQU1FLFNBQW1CLEVBQUU7SUFFM0IsTUFBTVUsV0FBV0gsYUFBYSxRQUFRQyxXQUFXLFFBQVFDLFFBQVE7SUFDakUsSUFBSUMsVUFBVTtRQUNWLE9BQU87WUFDSGQsaUJBQWlCVztZQUNqQlYsa0JBQWtCVztZQUNsQlYsY0FBY1c7WUFDZFYsUUFBUTtZQUNSQyxRQUFRO2dCQUFDO2FBQWtDO1FBQy9DO0lBQ0o7SUFFQSx5Q0FBeUM7SUFDekMsSUFBSU8sYUFBYSxPQUFPO1FBQ3BCUCxPQUFPVyxJQUFJLENBQUNKLGFBQWEsT0FBTyw2QkFBNkI7SUFDakU7SUFDQSxJQUFJQyxXQUFXLE9BQU87UUFDbEJSLE9BQU9XLElBQUksQ0FBQ0gsV0FBVyxPQUFPLHFDQUFx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O1lBQ2hDa0IsaUJBQWlCckIsU0FBUyxjQUFjO1lBQ3hDc0IsY0FBYzdILHFEQUFRQSxDQUFDdUcsU0FBUyxnQkFBZ0I7WUFDaER1QixTQUFTdkIsU0FBUyxXQUFXO1lBQzdCd0Isa0JBQWtCeEIsU0FBUyxnQkFBZ0I7WUFDM0N5Qix1QkFBdUJ6QixTQUFTLGVBQWU7WUFDL0MwQix3QkFBd0IxQixTQUFTLGdCQUFnQjtZQUNqRDJCLHVCQUF1QjNCLFNBQVMsZUFBZTtZQUMvQzRCLHdCQUF3QjtZQUN4QkMseUJBQXlCO1lBQ3pCQyx3QkFBd0I7UUFDNUI7SUFDSixFQUFFLE9BQU9oRSxPQUFPO1FBQ1poRCxRQUFRZ0QsS0FBSyxDQUFDLDhCQUE4QkEsT0FBT2I7UUFDbkQsT0FBTztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbG9vZGRhc2hib2FyZC8uL3NyYy9saWIvYmFja2VuZC9nb29nbGUtc2hlZXRzLWNsaWVudC50cz9iNWRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR29vZ2xlIFNoZWV0cyBDbGllbnQgLSBGZXRjaGVzIHB1Ymxpc2hlZCBYTFNYIGZpbGVzIGRpcmVjdGx5XG4gKi9cblxuaW1wb3J0IHsgU0hFRVRfU09VUkNFUyB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgUGFja2FnZUNvbXBsaWFuY2UsIENvbXBsaWFuY2VTdGF0dXMsIFRhc2ssIElQQ0RhdGEgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlRE1ZIH0gZnJvbSAnLi4vZGF0YVBhcnNlcic7XG5cbmludGVyZmFjZSBSYXdDb21wbGlhbmNlRGF0YSB7XG4gICAgbm9fb2Zfc3RhZmZfcmZiOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsO1xuICAgIGNlc21wc19zdWJtaXR0ZWQ6IHN0cmluZyB8IG51bGw7XG4gICAgb2hzX21lYXN1cmVzOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgU2hlZXRSb3cge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgcmF3IGNvbXBsaWFuY2UgZGF0YSBpbnRvIFBhY2thZ2VDb21wbGlhbmNlIHdpdGggc3RhdHVzIGxvZ2ljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29tcGxpYW5jZURhdGEocmF3OiBSYXdDb21wbGlhbmNlRGF0YSB8IG51bGwpOiBQYWNrYWdlQ29tcGxpYW5jZSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vX29mX3N0YWZmX3JmYjogbnVsbCxcbiAgICAgICAgICAgIGNlc21wc19zdWJtaXR0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvaHNfbWVhc3VyZXM6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6ICdVTktOT1dOJyxcbiAgICAgICAgICAgIGlzc3VlczogWydDb21wbGlhbmNlIGRhdGEgbm90IGF2YWlsYWJsZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFBhcnNlIFllcy9ObyBmaWVsZHMgKGFsbCB0aHJlZSBhcmUgWWVzL05vIGZvcm1hdClcbiAgICBjb25zdCBwYXJzZVllc05vID0gKHZhbDogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCk6ICdZZXMnIHwgJ05vJyB8IG51bGwgPT4ge1xuICAgICAgICBpZiAoIXZhbCAmJiB2YWwgIT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGlmIChub3JtYWxpemVkID09PSAneWVzJykgcmV0dXJuICdZZXMnO1xuICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gJ25vJykgcmV0dXJuICdObyc7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBzdGFmZlJmYiA9IHBhcnNlWWVzTm8ocmF3Lm5vX29mX3N0YWZmX3JmYik7XG4gICAgY29uc3QgY2VzbXBzID0gcGFyc2VZZXNObyhyYXcuY2VzbXBzX3N1Ym1pdHRlZCk7XG4gICAgY29uc3Qgb2hzID0gcGFyc2VZZXNObyhyYXcub2hzX21lYXN1cmVzKTtcblxuICAgIC8vIERldGVybWluZSBzdGF0dXMgYW5kIGlzc3Vlc1xuICAgIGNvbnN0IGlzc3Vlczogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0IGFsbEJsYW5rID0gc3RhZmZSZmIgPT09IG51bGwgJiYgY2VzbXBzID09PSBudWxsICYmIG9ocyA9PT0gbnVsbDtcbiAgICBpZiAoYWxsQmxhbmspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vX29mX3N0YWZmX3JmYjogc3RhZmZSZmIsXG4gICAgICAgICAgICBjZXNtcHNfc3VibWl0dGVkOiBjZXNtcHMsXG4gICAgICAgICAgICBvaHNfbWVhc3VyZXM6IG9ocyxcbiAgICAgICAgICAgIHN0YXR1czogJ1VOS05PV04nLFxuICAgICAgICAgICAgaXNzdWVzOiBbJ0FsbCBjb21wbGlhbmNlIGZpZWxkcyBhcmUgYmxhbmsnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGZvciBjb21wbGlhbmNlIGlzc3Vlc1xuICAgIGlmIChzdGFmZlJmYiAhPT0gJ1llcycpIHtcbiAgICAgICAgaXNzdWVzLnB1c2goc3RhZmZSZmIgPT09IG51bGwgPyAnU3RhZmYgUkZCIHN0YXR1cyB1bmtub3duJyA6ICdTdGFmZiBSRkIgbm90IHN1Ym1pdHRlZCcpO1xuICAgIH1cbiAgICBpZiAoY2VzbXBzICE9PSAnWWVzJykge1xuICAgICAgICBpc3N1ZXMucHVzaChjZXNtcHMgPT09IG51bGwgPyAnQ0VTTVBTIHN1Ym1pc3Npb24gc3RhdHVzIHVua25vd24nIDogJ0NFU01QUyBub3Qgc3VibWl0dGVkJyk7XG4gICAgfVxuICAgIGlmIChvaHMgIT09ICdZZXMnKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKG9ocyA9PT0gbnVsbCA/ICdPSFMgbWVhc3VyZXMgc3RhdHVzIHVua25vd24nIDogJ09IUyBtZWFzdXJlcyBub3QgaW4gcGxhY2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXM6IENvbXBsaWFuY2VTdGF0dXMgPSBpc3N1ZXMubGVuZ3RoID09PSAwID8gJ0NPTVBMSUFOVCcgOiAnTk9OX0NPTVBMSUFOVCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBub19vZl9zdGFmZl9yZmI6IHN0YWZmUmZiLCAvLyBLZWVwIGFzICdZZXMnIHwgJ05vJyB8IG51bGxcbiAgICAgICAgY2VzbXBzX3N1Ym1pdHRlZDogY2VzbXBzLFxuICAgICAgICBvaHNfbWVhc3VyZXM6IG9ocyxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc3N1ZXMsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbXBsaWFuY2UgZGF0YSBmcm9tIHB1Ymxpc2hlZCBYTFNYIGZpbGVzXG4gKiBSZWFkcyByb3cgMiAoY29sdW1ucyBWLCBXLCBYKSBmb3IgY29tcGxpYW5jZSBtZXRhZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxDb21wbGlhbmNlRGF0YSgpOiBQcm9taXNlPE1hcDxzdHJpbmcsIFBhY2thZ2VDb21wbGlhbmNlPj4ge1xuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIGNvbXBsaWFuY2UgZGF0YSBmcm9tIHB1Ymxpc2hlZCBYTFNYIGZpbGVzLi4uJyk7XG5cbiAgICBjb25zdCBjb21wbGlhbmNlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFBhY2thZ2VDb21wbGlhbmNlPigpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgICAgU0hFRVRfU09VUkNFUy5tYXAoYXN5bmMgKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiyBGZXRjaGluZyBjb21wbGlhbmNlIGZvciAke3NvdXJjZS5wYWNrYWdlSWR9Li4uYCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNvdXJjZS5wdWJsaXNoZWRYbHN4VXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIFhMU1g6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIC8vIEltcG9ydCBYTFNYIGR5bmFtaWNhbGx5XG4gICAgICAgICAgICAgICAgY29uc3QgWExTWCA9IGF3YWl0IGltcG9ydCgneGxzeCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtib29rID0gWExTWC5yZWFkKGRhdGEsIHsgdHlwZTogJ2FycmF5JywgY2VsbERhdGVzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBEYXRhX0VudHJ5IHNoZWV0XG4gICAgICAgICAgICAgICAgbGV0IHNoZWV0TmFtZSA9ICdEYXRhX0VudHJ5JztcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmtib29rLlNoZWV0TmFtZXMuaW5jbHVkZXMoc2hlZXROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzaGVldE5hbWUgPSB3b3JrYm9vay5TaGVldE5hbWVzWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25Sb3dzID0gWExTWC51dGlscy5zaGVldF90b19qc29uPFNoZWV0Um93Pih3b3Jrc2hlZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmdmFsOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVidWc6IGxvZyBmaXJzdCByb3cgdG8gc2VlIGFsbCBjb2x1bW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4sgJHtzb3VyY2UucGFja2FnZUlkfSAtIFRvdGFsIHJvd3M6ICR7anNvblJvd3MubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGlmIChqc29uUm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLICR7c291cmNlLnBhY2thZ2VJZH0gLSBSb3cgMSBjb2x1bW5zOmAsIE9iamVjdC5rZXlzKGpzb25Sb3dzWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLICR7c291cmNlLnBhY2thZ2VJZH0gLSBSb3cgMSBkYXRhOmAsIGpzb25Sb3dzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSb3cgMiBpcyBhdCBpbmRleCAwIChzaW5jZSBzaGVldF90b19qc29uIHNraXBzIGhlYWRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGpzb25Sb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0ganNvblJvd3NbMF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBjb2x1bW5zIHdpdGggZGlmZmVyZW50IHBvc3NpYmxlIG5hbWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWZmUmZiTmFtZXMgPSBbJ05vX29mX1N0YWZmX1JGQicsICdObyBvZiBTdGFmZiBSRkInLCAnU3RhZmYgUkZCJywgJ05vX29mX1N0YWZmX1JGQiddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZXNtcE5hbWVzID0gWydDRVNNUFNfU3VibWl0dGVkJywgJ0NFU01QU19TdWJtaXR0ZScsICdDRU1TUFNfU3VibWl0dGVkJywgJ0NFU01QUyddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvaHNOYW1lcyA9IFsnT0hTX01lYXN1cmVzJywgJ09IUyBNZWFzdXJlcycsICdPSFMnLCAnT0hTX01lYXN1cmVzJ107XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWZmVmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VzbXBzVmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2hzVmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xOYW1lIG9mIHN0YWZmUmZiTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xOYW1lIGluIHJvdyAmJiByb3dbY29sTmFtZV0gIT09IG51bGwgJiYgcm93W2NvbE5hbWVdICE9PSB1bmRlZmluZWQgJiYgcm93W2NvbE5hbWVdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWZmVmFsdWUgPSByb3dbY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3NvdXJjZS5wYWNrYWdlSWR9IC0gRm91bmQgU3RhZmYgUkZCIGF0IFwiJHtjb2xOYW1lfVwiOiAke3N0YWZmVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbE5hbWUgb2YgY2VzbXBOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbE5hbWUgaW4gcm93ICYmIHJvd1tjb2xOYW1lXSAhPT0gbnVsbCAmJiByb3dbY29sTmFtZV0gIT09IHVuZGVmaW5lZCAmJiByb3dbY29sTmFtZV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VzbXBzVmFsdWUgPSByb3dbY29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3NvdXJjZS5wYWNrYWdlSWR9IC0gRm91bmQgQ0VTTVBTIGF0IFwiJHtjb2xOYW1lfVwiOiAke2Nlc21wc1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xOYW1lIG9mIG9oc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sTmFtZSBpbiByb3cgJiYgcm93W2NvbE5hbWVdICE9PSBudWxsICYmIHJvd1tjb2xOYW1lXSAhPT0gdW5kZWZpbmVkICYmIHJvd1tjb2xOYW1lXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvaHNWYWx1ZSA9IHJvd1tjb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7c291cmNlLnBhY2thZ2VJZH0gLSBGb3VuZCBPSFMgYXQgXCIke2NvbE5hbWV9XCI6ICR7b2hzVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdEYXRhOiBSYXdDb21wbGlhbmNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vX29mX3N0YWZmX3JmYjogc3RhZmZWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlc21wc19zdWJtaXR0ZWQ6IGNlc21wc1ZhbHVlPy50b1N0cmluZygpID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvaHNfbWVhc3VyZXM6IG9oc1ZhbHVlPy50b1N0cmluZygpID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4sgJHtzb3VyY2UucGFja2FnZUlkfSAtIEZpbmFsIHJhdyBkYXRhOmAsIHJhd0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGlhbmNlID0gcGFyc2VDb21wbGlhbmNlRGF0YShyYXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZUlkOiBzb3VyY2UucGFja2FnZUlkLCBjb21wbGlhbmNlIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gTm8gcm93IDEgZGF0YSBmb3VuZCBmb3IgJHtzb3VyY2UucGFja2FnZUlkfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwYWNrYWdlSWQ6IHNvdXJjZS5wYWNrYWdlSWQsIGNvbXBsaWFuY2U6IHBhcnNlQ29tcGxpYW5jZURhdGEobnVsbCkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgY29tcGxpYW5jZSBmb3IgJHtzb3VyY2UucGFja2FnZUlkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZUlkOiBzb3VyY2UucGFja2FnZUlkLCBjb21wbGlhbmNlOiBwYXJzZUNvbXBsaWFuY2VEYXRhKG51bGwpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICAgICAgY29uc3QgeyBwYWNrYWdlSWQsIGNvbXBsaWFuY2UgfSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGNvbXBsaWFuY2VNYXAuc2V0KHBhY2thZ2VJZCwgY29tcGxpYW5jZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENvbXBsaWFuY2UgZm9yICR7cGFja2FnZUlkfTogJHtjb21wbGlhbmNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbXBsaWFuY2VNYXA7XG59XG5cbi8qKlxuICogVHlwZSBkZWZpbml0aW9ucyBmb3Igc2FmZSBjZWxsIGFjY2Vzc1xuICovXG5pbnRlcmZhY2UgU2hlZXRDZWxsIHtcbiAgICB2Pzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGw7XG4gICAgdD86IHN0cmluZztcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG5pbnRlcmZhY2UgV29ya1NoZWV0IHtcbiAgICBbY2VsbEtleTogc3RyaW5nXTogU2hlZXRDZWxsIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFBhcnNlIElQQyAoSW50ZXJpbSBQYXltZW50IENlcnRpZmljYXRlKSBkYXRhIGZyb20gWExTWCB3b3Jrc2hlZXRcbiAqIFJlYWRzIHJvdyAyLCBjb2x1bW5zIFktQUQgKDAtaW5kZXhlZCBjb2x1bW5zIDI0LTI5KVxuICovXG5mdW5jdGlvbiBwYXJzZUlQQ0RhdGEoXG4gICAgc2hlZXQ6IFdvcmtTaGVldCAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIHhsc3hVdGlsczogYW55XG4pOiBJUENEYXRhIHtcbiAgICBjb25zb2xlLmxvZygnW0lQQ0RhdGFdIFN0YXJ0aW5nIHRvIHBhcnNlIElQQyBkYXRhLi4uJyk7XG4gICAgY29uc29sZS5sb2coJ1tJUENEYXRhXSBTaGVldCAhcmVmOicsIHNoZWV0WychcmVmJ10pO1xuICAgIGNvbnNvbGUubG9nKCdbSVBDRGF0YV0gQWxsIHNoZWV0IGtleXM6JywgT2JqZWN0LmtleXMoc2hlZXQpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJyEnKSkuc2xpY2UoMCwgMjApKTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgICBjb25zdCBzdGF0dXNNYXA6IFJlY29yZDxzdHJpbmcsICdub3Qgc3VibWl0dGVkJyB8ICdzdWJtaXR0ZWQnIHwgJ2luIHByb2Nlc3MnIHwgJ3JlbGVhc2VkJz4gPSB7XG4gICAgICAgICdub3Qgc3VibWl0dGVkJzogJ25vdCBzdWJtaXR0ZWQnLFxuICAgICAgICAnc3VibWl0dGVkJzogJ3N1Ym1pdHRlZCcsXG4gICAgICAgICdpbiBwcm9jZXNzJzogJ2luIHByb2Nlc3MnLFxuICAgICAgICAncmVsZWFzZWQnOiAncmVsZWFzZWQnLFxuICAgIH07XG5cbiAgICAvLyBSZWFkIGNvbHVtbnMgMjQtMjkgKFktQUQpIGZyb20gcm93IDIgKGluZGV4IDEpXG4gICAgZm9yIChsZXQgY29sID0gMjQ7IGNvbCA8PSAyOTsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbFJlZiA9IHhsc3hVdGlscy5lbmNvZGVfY2VsbCh7IHI6IDEsIGM6IGNvbCB9KTtcbiAgICAgICAgY29uc3QgY2VsbFZhbHVlID0gc2hlZXRbY2VsbFJlZl07XG5cbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgW0lQQ0RhdGFdIFJlYWRpbmcgUm93IDIsIENvbHVtbiAke2NvbH0gKCR7Y2VsbFJlZn0pOmAsXG4gICAgICAgICAgICBjZWxsVmFsdWUgPyAodHlwZW9mIGNlbGxWYWx1ZSA9PT0gJ29iamVjdCcgJiYgJ3YnIGluIGNlbGxWYWx1ZSA/IGNlbGxWYWx1ZS52IDogY2VsbFZhbHVlKSA6ICd1bmRlZmluZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHN0YXR1c1Jhdzogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNlbGxWYWx1ZSAmJiB0eXBlb2YgY2VsbFZhbHVlID09PSAnb2JqZWN0JyAmJiAndicgaW4gY2VsbFZhbHVlICYmIGNlbGxWYWx1ZS52KSB7XG4gICAgICAgICAgICBzdGF0dXNSYXcgPSBTdHJpbmcoY2VsbFZhbHVlLnYpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXBjTnVtYmVyID0gYElQQyAke2NvbCAtIDIzfWA7IC8vIElQQyAxLTZcbiAgICAgICAgY29uc3QgbWFwcGVkU3RhdHVzID0gc3RhdHVzUmF3ICYmIHN0YXR1c1JhdyBpbiBzdGF0dXNNYXAgPyBzdGF0dXNNYXBbc3RhdHVzUmF3XSA6IG51bGw7XG5cbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgW0lQQ0RhdGFdICAg4oaSIElQQyBOdW1iZXI6ICR7aXBjTnVtYmVyfSwgUmF3OiBcIiR7c3RhdHVzUmF3fVwiLCBNYXBwZWQ6IFwiJHttYXBwZWRTdGF0dXN9XCJgXG4gICAgICAgICk7XG5cbiAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgIGlwY051bWJlcixcbiAgICAgICAgICAgIHN0YXR1czogbWFwcGVkU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW0lQQ0RhdGFdIEZpbmFsIHBhcnNlZCByZWNvcmRzOicsIHJlY29yZHMpO1xuICAgIGNvbnNvbGUubG9nKCdbSVBDRGF0YV0gTm9uLW51bGwgcmVjb3JkczonLCByZWNvcmRzLmZpbHRlcihyID0+IHIuc3RhdHVzICE9PSBudWxsKS5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHsgcmVjb3JkcyB9O1xufVxuXG4vKipcbiAqIEZldGNoIElQQyBkYXRhIGZyb20gcHVibGlzaGVkIFhMU1hcbiAqIEV4dHJhY3RzIGludGVyaW0gcGF5bWVudCBjZXJ0aWZpY2F0ZSBzdGF0dXNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxJUENEYXRhKCk6IFByb21pc2U8SVBDRGF0YT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbSVBDRGF0YV0gU3RhcnRpbmcgSVBDIGRhdGEgZmV0Y2guLi4nKTtcblxuICAgICAgICBpZiAoU0hFRVRfU09VUkNFUy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0lQQ0RhdGFdIE5vIHNoZWV0IHNvdXJjZXMgY29uZmlndXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVjb3JkczogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IFNIRUVUX1NPVVJDRVNbMF07XG4gICAgICAgIGNvbnNvbGUubG9nKGBbSVBDRGF0YV0gRmV0Y2hpbmcgZnJvbSAke3NvdXJjZS5wYWNrYWdlSWR9OiAke3NvdXJjZS5wdWJsaXNoZWRYbHN4VXJsfWApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc291cmNlLnB1Ymxpc2hlZFhsc3hVcmwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBYTFNYOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgLy8gSW1wb3J0IFhMU1ggZHluYW1pY2FsbHlcbiAgICAgICAgY29uc3QgWExTWCA9IGF3YWl0IGltcG9ydCgneGxzeCcpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0lQQ0RhdGFdIFhMU1ggbGlicmFyeSBsb2FkZWQnKTtcblxuICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScsIGNlbGxEYXRlczogdHJ1ZSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tJUENEYXRhXSBXb3JrYm9vayBsb2FkZWQsIHNoZWV0czonLCB3b3JrYm9vay5TaGVldE5hbWVzKTtcblxuICAgICAgICAvLyBGaW5kIERhdGFfRW50cnkgc2hlZXRcbiAgICAgICAgbGV0IHNoZWV0TmFtZSA9ICdEYXRhX0VudHJ5JztcbiAgICAgICAgaWYgKCF3b3JrYm9vay5TaGVldE5hbWVzLmluY2x1ZGVzKHNoZWV0TmFtZSkpIHtcbiAgICAgICAgICAgIHNoZWV0TmFtZSA9IHdvcmtib29rLlNoZWV0TmFtZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXSBhcyBXb3JrU2hlZXQgJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgY29uc29sZS5sb2coYFtJUENEYXRhXSBVc2luZyBzaGVldDogJHtzaGVldE5hbWV9YCk7XG5cbiAgICAgICAgY29uc3QgaXBjRGF0YSA9IHBhcnNlSVBDRGF0YSh3b3Jrc2hlZXQsIFhMU1gudXRpbHMpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0lQQ0RhdGFdIOKchSBJUEMgZGF0YSBwYXJzZWQgc3VjY2Vzc2Z1bGx5OicsIGlwY0RhdGEpO1xuXG4gICAgICAgIHJldHVybiBpcGNEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tJUENEYXRhXSDinYwgRXJyb3IgZmV0Y2hpbmcgSVBDIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyByZWNvcmRzOiBbXSB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhbGwgcHVibGlzaGVkIHNoZWV0cyBhcyBYTFNYIGFuZCByZXR1cm4gcmF3IHJvd3MgZm9yIHRhc2sgcGFyc2luZ1xuICogVXNlZCBmb3IgaW5nZXN0aW5nIHRhc2sgZGF0YSAobm90IGNvbXBsaWFuY2UgLSBjb21wbGlhbmNlIGlzIGV4dHJhY3RlZCBzZXBhcmF0ZWx5KVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxTaGVldHMoKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBTaGVldFJvd1tdPj4ge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwdWJsaXNoZWQgWExTWCBzaGVldHMgZm9yIHRhc2sgZGF0YS4uLicpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgICAgU0hFRVRfU09VUkNFUy5tYXAoYXN5bmMgKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNvdXJjZS5wdWJsaXNoZWRYbHN4VXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIFhMU1g6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IFhMU1ggPSBhd2FpdCBpbXBvcnQoJ3hsc3gnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScsIGNlbGxEYXRlczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGxldCBzaGVldE5hbWUgPSAnRGF0YV9FbnRyeSc7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JrYm9vay5TaGVldE5hbWVzLmluY2x1ZGVzKHNoZWV0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXROYW1lID0gd29ya2Jvb2suU2hlZXROYW1lc1swXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uRGF0YSA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbjxTaGVldFJvdz4od29ya3NoZWV0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJhdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlZnZhbDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIERlYnVnOiBsb2cgYWxsIGF2YWlsYWJsZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4sgJHtzb3VyY2UucGFja2FnZUlkfSAtIFRvdGFsIHJvd3M6ICR7anNvbkRhdGEubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGlmIChqc29uRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLICR7c291cmNlLnBhY2thZ2VJZH0gLSBDb2x1bW4gaGVhZGVyczpgLCBPYmplY3Qua2V5cyhqc29uRGF0YVswXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiyAke3NvdXJjZS5wYWNrYWdlSWR9IC0gUm93IDIgZGF0YTpgLCBqc29uRGF0YVswXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZUlkOiBzb3VyY2UucGFja2FnZUlkLCByb3dzOiBqc29uRGF0YSB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzaGVldCAke3NvdXJjZS5wYWNrYWdlSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgY29uc3QgZGF0YU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBTaGVldFJvd1tdPigpO1xuXG4gICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IFNIRUVUX1NPVVJDRVNbaW5kZXhdO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFja2FnZUlkLCByb3dzIH0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBkYXRhTWFwLnNldChwYWNrYWdlSWQsIHJvd3MpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGZXRjaGVkICR7cm93cy5sZW5ndGh9IHJvd3MgZnJvbSAke3BhY2thZ2VJZH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gZmV0Y2ggJHtzb3VyY2UucGFja2FnZUlkfTpgLCByZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgIGRhdGFNYXAuc2V0KHNvdXJjZS5wYWNrYWdlSWQsIFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGFNYXA7XG59XG5cbi8qKlxuICogTWFwIHJhdyBzaGVldCByb3cgdG8gVGFzayBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFJvd1RvVGFzayhyb3c6IFNoZWV0Um93LCBwYWNrYWdlSWQ6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZyk6IFRhc2sgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBTa2lwIGVtcHR5IHJvd3NcbiAgICAgICAgaWYgKCFyb3dbJ1NpdGUgSUQnXSAmJiAhcm93WydzaXRlX2lkJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGJvdGggcG9zc2libGUgaGVhZGVyIGZvcm1hdHNcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSAoa2V5MTogc3RyaW5nLCBrZXkyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gcm93W2tleTFdIHx8IHJvd1trZXkyXTtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPyBTdHJpbmcodmFsKS50cmltKCkgOiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXROdW1iZXIgPSAoa2V5MTogc3RyaW5nLCBrZXkyOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHJvd1trZXkxXSB8fCByb3dba2V5Ml07XG4gICAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gJycpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4obnVtKSA/IG51bGwgOiBudW07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhY2thZ2VfaWQ6IHBhY2thZ2VJZCxcbiAgICAgICAgICAgIHBhY2thZ2VfbmFtZTogcGFja2FnZU5hbWUsXG4gICAgICAgICAgICBkaXN0cmljdDogZ2V0VmFsdWUoJ0Rpc3RyaWN0JywgJ2Rpc3RyaWN0JyksXG4gICAgICAgICAgICBzaXRlX2lkOiBnZXRWYWx1ZSgnU2l0ZSBJRCcsICdzaXRlX2lkJyksXG4gICAgICAgICAgICBzaXRlX25hbWU6IGdldFZhbHVlKCdTaXRlIE5hbWUnLCAnc2l0ZV9uYW1lJyksXG4gICAgICAgICAgICBkaXNjaXBsaW5lOiBnZXRWYWx1ZSgnRGlzY2lwbGluZScsICdkaXNjaXBsaW5lJyksXG4gICAgICAgICAgICB0YXNrX25hbWU6IGdldFZhbHVlKCdUYXNrIE5hbWUnLCAndGFza19uYW1lJyksXG4gICAgICAgICAgICBwbGFubmVkX3N0YXJ0OiBwYXJzZURNWShnZXRWYWx1ZSgnUGxhbm5lZCBTdGFydCcsICdwbGFubmVkX3N0YXJ0JykpLFxuICAgICAgICAgICAgcGxhbm5lZF9maW5pc2g6IHBhcnNlRE1ZKGdldFZhbHVlKCdQbGFubmVkIEZpbmlzaCcsICdwbGFubmVkX2ZpbmlzaCcpKSxcbiAgICAgICAgICAgIHBsYW5uZWRfZHVyYXRpb25fZGF5czogZ2V0TnVtYmVyKCdQbGFubmVkIER1cmF0aW9uIChEYXlzKScsICdwbGFubmVkX2R1cmF0aW9uX2RheXMnKSxcbiAgICAgICAgICAgIGFjdHVhbF9zdGFydDogcGFyc2VETVkoZ2V0VmFsdWUoJ0FjdHVhbCBTdGFydCcsICdhY3R1YWxfc3RhcnQnKSksXG4gICAgICAgICAgICBhY3R1YWxfZmluaXNoOiBwYXJzZURNWShnZXRWYWx1ZSgnQWN0dWFsIEZpbmlzaCcsICdhY3R1YWxfZmluaXNoJykpLFxuICAgICAgICAgICAgcHJvZ3Jlc3NfcGN0OiBnZXROdW1iZXIoJ1Byb2dyZXNzICUnLCAncHJvZ3Jlc3NfcGN0JyksXG4gICAgICAgICAgICBWYXJpYW5jZTogZ2V0TnVtYmVyKCdWYXJpYW5jZScsICdWYXJpYW5jZScpLFxuICAgICAgICAgICAgZGVsYXlfZmxhZ19jYWxjOiBnZXRWYWx1ZSgnRGVsYXkgRmxhZycsICdkZWxheV9mbGFnX2NhbGMnKSxcbiAgICAgICAgICAgIGxhc3RfdXBkYXRlZDogcGFyc2VETVkoZ2V0VmFsdWUoJ0xhc3QgVXBkYXRlZCcsICdsYXN0X3VwZGF0ZWQnKSksXG4gICAgICAgICAgICByZW1hcmtzOiBnZXRWYWx1ZSgnUmVtYXJrcycsICdyZW1hcmtzJyksXG4gICAgICAgICAgICBwaG90b19mb2xkZXJfdXJsOiBnZXRWYWx1ZSgnUGhvdG8gRm9sZGVyJywgJ3Bob3RvX2ZvbGRlcl91cmwnKSxcbiAgICAgICAgICAgIGNvdmVyX3Bob3RvX3NoYXJlX3VybDogZ2V0VmFsdWUoJ0NvdmVyIFBob3RvJywgJ2NvdmVyX3Bob3RvX3NoYXJlX3VybCcpLFxuICAgICAgICAgICAgYmVmb3JlX3Bob3RvX3NoYXJlX3VybDogZ2V0VmFsdWUoJ0JlZm9yZSBQaG90bycsICdiZWZvcmVfcGhvdG9fc2hhcmVfdXJsJyksXG4gICAgICAgICAgICBhZnRlcl9waG90b19zaGFyZV91cmw6IGdldFZhbHVlKCdBZnRlciBQaG90bycsICdhZnRlcl9waG90b19zaGFyZV91cmwnKSxcbiAgICAgICAgICAgIGNvdmVyX3Bob3RvX2RpcmVjdF91cmw6IG51bGwsXG4gICAgICAgICAgICBiZWZvcmVfcGhvdG9fZGlyZWN0X3VybDogbnVsbCxcbiAgICAgICAgICAgIGFmdGVyX3Bob3RvX2RpcmVjdF91cmw6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFwcGluZyByb3cgdG8gdGFzazonLCBlcnJvciwgcm93KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlNIRUVUX1NPVVJDRVMiLCJwYXJzZURNWSIsInBhcnNlQ29tcGxpYW5jZURhdGEiLCJyYXciLCJub19vZl9zdGFmZl9yZmIiLCJjZXNtcHNfc3VibWl0dGVkIiwib2hzX21lYXN1cmVzIiwic3RhdHVzIiwiaXNzdWVzIiwicGFyc2VZZXNObyIsInZhbCIsIm5vcm1hbGl6ZWQiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJzdGFmZlJmYiIsImNlc21wcyIsIm9ocyIsImFsbEJsYW5rIiwicHVzaCIsImxlbmd0aCIsImZldGNoQWxsQ29tcGxpYW5jZURhdGEiLCJjb25zb2xlIiwibG9nIiwiY29tcGxpYW5jZU1hcCIsIk1hcCIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsIm1hcCIsInNvdXJjZSIsInBhY2thZ2VJZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJwdWJsaXNoZWRYbHN4VXJsIiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJhcnJheUJ1ZmZlciIsImRhdGEiLCJVaW50OEFycmF5IiwiWExTWCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJjZWxsRGF0ZXMiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwiaW5jbHVkZXMiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJqc29uUm93cyIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsImRlZnZhbCIsIk9iamVjdCIsImtleXMiLCJyb3ciLCJzdGFmZlJmYk5hbWVzIiwiY2VzbXBOYW1lcyIsIm9oc05hbWVzIiwic3RhZmZWYWx1ZSIsImNlc21wc1ZhbHVlIiwib2hzVmFsdWUiLCJjb2xOYW1lIiwidW5kZWZpbmVkIiwicmF3RGF0YSIsInRvU3RyaW5nIiwiY29tcGxpYW5jZSIsIndhcm4iLCJlcnJvciIsImZvckVhY2giLCJyZXN1bHQiLCJ2YWx1ZSIsInNldCIsInBhcnNlSVBDRGF0YSIsInNoZWV0IiwieGxzeFV0aWxzIiwiZmlsdGVyIiwiayIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInJlY29yZHMiLCJzdGF0dXNNYXAiLCJjb2wiLCJjZWxsUmVmIiwiZW5jb2RlX2NlbGwiLCJyIiwiYyIsImNlbGxWYWx1ZSIsInYiLCJzdGF0dXNSYXciLCJpcGNOdW1iZXIiLCJtYXBwZWRTdGF0dXMiLCJmZXRjaEFsbElQQ0RhdGEiLCJpcGNEYXRhIiwiZmV0Y2hBbGxTaGVldHMiLCJqc29uRGF0YSIsInJvd3MiLCJkYXRhTWFwIiwiaW5kZXgiLCJyZWFzb24iLCJtYXBSb3dUb1Rhc2siLCJwYWNrYWdlTmFtZSIsImdldFZhbHVlIiwia2V5MSIsImtleTIiLCJnZXROdW1iZXIiLCJudW0iLCJOdW1iZXIiLCJpc05hTiIsInBhY2thZ2VfaWQiLCJwYWNrYWdlX25hbWUiLCJkaXN0cmljdCIsInNpdGVfaWQiLCJzaXRlX25hbWUiLCJkaXNjaXBsaW5lIiwidGFza19uYW1lIiwicGxhbm5lZF9zdGFydCIsInBsYW5uZWRfZmluaXNoIiwicGxhbm5lZF9kdXJhdGlvbl9kYXlzIiwiYWN0dWFsX3N0YXJ0IiwiYWN0dWFsX2ZpbmlzaCIsInByb2dyZXNzX3BjdCIsIlZhcmlhbmNlIiwiZGVsYXlfZmxhZ19jYWxjIiwibGFzdF91cGRhdGVkIiwicmVtYXJrcyIsInBob3RvX2ZvbGRlcl91cmwiLCJjb3Zlcl9waG90b19zaGFyZV91cmwiLCJiZWZvcmVfcGhvdG9fc2hhcmVfdXJsIiwiYWZ0ZXJfcGhvdG9fc2hhcmVfdXJsIiwiY292ZXJfcGhvdG9fZGlyZWN0X3VybCIsImJlZm9yZV9waG90b19kaXJlY3RfdXJsIiwiYWZ0ZXJfcGhvdG9fZGlyZWN0X3VybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/lib/backend/google-sheets-client.ts\n");

/***/ }),

/***/ "(api)/./src/lib/dataParser.ts":
/*!*******************************!*\
  !*** ./src/lib/dataParser.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clampProgress: () => (/* binding */ clampProgress),\n/* harmony export */   computeTaskStatus: () => (/* binding */ computeTaskStatus),\n/* harmony export */   excelDateToJSDate: () => (/* binding */ excelDateToJSDate),\n/* harmony export */   extractDriveFile: () => (/* binding */ extractDriveFile),\n/* harmony export */   parseDMY: () => (/* binding */ parseDMY),\n/* harmony export */   parseXLSXFile: () => (/* binding */ parseXLSXFile),\n/* harmony export */   resolvePhotoURL: () => (/* binding */ resolvePhotoURL),\n/* harmony export */   validateTaskData: () => (/* binding */ validateTaskData)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xlsx */ \"xlsx\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xlsx__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs */ \"dayjs\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var dayjs_plugin_customParseFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs/plugin/customParseFormat */ \"dayjs/plugin/customParseFormat\");\n/* harmony import */ var dayjs_plugin_customParseFormat__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_customParseFormat__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/types */ \"(api)/./src/types/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_types__WEBPACK_IMPORTED_MODULE_3__]);\n_types__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n// Enable strict date parsing\ndayjs__WEBPACK_IMPORTED_MODULE_1___default().extend((dayjs_plugin_customParseFormat__WEBPACK_IMPORTED_MODULE_2___default()));\n// Constants\nconst STALE_DAYS = 14;\nconst AHEAD_DELTA = 10;\nconst ONTRACK_LOW = -10;\nconst ATRISK_LOW = -25;\n/**\n * Parse DD-MM-YYYY or DD/MM/YYYY date strings strictly\n */ function parseDMY(value) {\n    if (!value) return null;\n    // Handle Excel serial dates (numbers)\n    if (typeof value === \"number\") {\n        return excelDateToJSDate(value);\n    }\n    // Handle date objects\n    if (value instanceof Date) {\n        return value;\n    }\n    // Handle string dates\n    if (typeof value === \"string\") {\n        const str = value.trim();\n        // Try DD-MM-YYYY format (strict)\n        let parsed = dayjs__WEBPACK_IMPORTED_MODULE_1___default()(str, \"DD-MM-YYYY\", true);\n        if (parsed.isValid()) {\n            return parsed.toDate();\n        }\n        // Try DD/MM/YYYY format (strict)\n        parsed = dayjs__WEBPACK_IMPORTED_MODULE_1___default()(str, \"DD/MM/YYYY\", true);\n        if (parsed.isValid()) {\n            return parsed.toDate();\n        }\n        // Fallback to default parsing (less strict)\n        parsed = dayjs__WEBPACK_IMPORTED_MODULE_1___default()(str);\n        if (parsed.isValid()) {\n            return parsed.toDate();\n        }\n    }\n    return null;\n}\n/**\n * Convert Excel serial date to JS Date\n */ function excelDateToJSDate(serial) {\n    if (serial instanceof Date) return serial;\n    if (!serial) return null;\n    // If it's a string, try to parse it\n    if (typeof serial === \"string\") {\n        return parseDMY(serial);\n    }\n    // Excel serial date (days since 1900-01-01, but Excel incorrectly treats 1900 as leap year)\n    if (typeof serial === \"number\") {\n        const utc_days = Math.floor(serial - 25569);\n        const utc_value = utc_days * 86400;\n        const date_info = new Date(utc_value * 1000);\n        return date_info;\n    }\n    return null;\n}\n/**\n * Extract Google Drive file ID from URL\n */ function extractDriveFile(url) {\n    if (!url) return null;\n    // Match: /file/d/<ID>/ (drive.google.com or docs.google.com)\n    let match = url.match(/\\/file\\/d\\/([-\\w]+)/);\n    if (match) return match[1];\n    // Match: id=<ID> (including open?id= and uc?id=)\n    match = url.match(/[?&]id=([-\\w]+)/);\n    if (match) return match[1];\n    // Match: /open?id=<ID> (older style)\n    match = url.match(/\\/open\\?id=([-\\w]+)/);\n    if (match) return match[1];\n    // Match: /uc?id=<ID> (export link)\n    match = url.match(/\\/uc\\?id=([-\\w]+)/);\n    if (match) return match[1];\n    return null;\n}\n/**\n * Resolve Google Drive URLs to direct image URLs\n */ function resolvePhotoURL(directUrl, shareUrl) {\n    // Prefer direct URL\n    if (directUrl && directUrl.trim().length > 0) {\n        return {\n            resolved: directUrl,\n            status: \"direct-ok\"\n        };\n    }\n    // Try to extract file ID from share URL\n    if (shareUrl && shareUrl.trim().length > 0) {\n        const fileId = extractDriveFile(shareUrl);\n        if (fileId) {\n            const resolved = `https://drive.google.com/uc?export=view&id=${fileId}`;\n            return {\n                resolved,\n                status: \"resolved-from-share\"\n            };\n        }\n        return {\n            resolved: null,\n            status: \"unresolvable\"\n        };\n    }\n    return {\n        resolved: null,\n        status: \"missing\"\n    };\n}\n/**\n * Validate task data and return quality issues\n */ function validateTaskData(task, parsedDates) {\n    const issues = [];\n    const { planned_start, planned_finish, actual_start, actual_finish, last_updated } = parsedDates;\n    // Check: planned finish before start\n    if (planned_start && planned_finish && planned_finish < planned_start) {\n        issues.push(\"planned_finish_before_start\");\n    }\n    // Check: actual finish before start\n    if (actual_start && actual_finish && actual_finish < actual_start) {\n        issues.push(\"actual_finish_before_start\");\n    }\n    // Check: progress out of range (already clamped in schema, but flag it)\n    if (task.progress_pct !== null && (task.progress_pct < 0 || task.progress_pct > 100)) {\n        issues.push(\"progress_out_of_range\");\n    }\n    // Check: completed but missing actual_finish\n    if (task.progress_pct !== null && task.progress_pct >= 100 && !actual_finish) {\n        issues.push(\"completed_but_missing_actual_finish\");\n    }\n    // Check: missing planned dates\n    if (!planned_start || !planned_finish) {\n        issues.push(\"missing_planned_dates\");\n    }\n    // Check: stale update\n    if (last_updated) {\n        const daysSinceUpdate = dayjs__WEBPACK_IMPORTED_MODULE_1___default()().diff(dayjs__WEBPACK_IMPORTED_MODULE_1___default()(last_updated), \"day\");\n        if (daysSinceUpdate > STALE_DAYS) {\n            issues.push(\"stale_update\");\n        }\n    }\n    // Check: duration missing or zero\n    if (task.planned_duration_days === null || task.planned_duration_days <= 0) {\n        issues.push(\"duration_missing_or_zero\");\n    }\n    // Determine highest severity\n    let flag = null;\n    if (issues.includes(\"planned_finish_before_start\") || issues.includes(\"actual_finish_before_start\") || issues.includes(\"progress_out_of_range\")) {\n        flag = \"critical\";\n    } else if (issues.includes(\"completed_but_missing_actual_finish\") || issues.includes(\"missing_planned_dates\") || issues.includes(\"stale_update\")) {\n        flag = \"warning\";\n    } else if (issues.length > 0) {\n        flag = \"info\";\n    }\n    return {\n        issues,\n        flag\n    };\n}\n/**\n * Compute schedule intelligence and status for a task\n */ function computeTaskStatus(task) {\n    const today = new Date();\n    const today_epoch = today.getTime();\n    // Parse dates using DD-MM-YYYY parser\n    const planned_start = parseDMY(task.planned_start);\n    const planned_finish = parseDMY(task.planned_finish);\n    const actual_start = parseDMY(task.actual_start);\n    const actual_finish = parseDMY(task.actual_finish);\n    const last_updated = parseDMY(task.last_updated);\n    // Generate unique keys\n    const site_uid = `${task.package_id}|${task.district}|${task.site_id}`;\n    const task_uid = `${site_uid}|${task.discipline}|${task.task_name}`;\n    const siteKey = `${task.package_id}__${task.site_id}`; // Legacy format\n    // Task weight\n    const task_weight_days = Math.max(1, task.planned_duration_days || 1);\n    const task_weight_final = task_weight_days; // Can add override logic later\n    // Validate data quality\n    const qualityReport = validateTaskData(task, {\n        planned_start,\n        planned_finish,\n        actual_start,\n        actual_finish,\n        last_updated\n    });\n    // Stale update check\n    const stale_update_flag = last_updated ? dayjs__WEBPACK_IMPORTED_MODULE_1___default()(today).diff(dayjs__WEBPACK_IMPORTED_MODULE_1___default()(last_updated), \"day\") > STALE_DAYS : false;\n    // Calculate planned progress (baseline)\n    let planned_progress_pct = null;\n    if (planned_start && planned_finish) {\n        const S = planned_start.getTime();\n        const F = planned_finish.getTime();\n        const T = today_epoch;\n        if (T <= S) {\n            planned_progress_pct = 0;\n        } else if (T >= F) {\n            planned_progress_pct = 100;\n        } else {\n            planned_progress_pct = (T - S) / (F - S) * 100;\n        }\n    }\n    // Progress delta\n    const progress_delta_pct = task.progress_pct !== null && planned_progress_pct !== null ? task.progress_pct - planned_progress_pct : null;\n    // Schedule bucket\n    let schedule_bucket = null;\n    if (progress_delta_pct !== null) {\n        if (progress_delta_pct > AHEAD_DELTA) {\n            schedule_bucket = \"ahead\";\n        } else if (progress_delta_pct >= ONTRACK_LOW) {\n            schedule_bucket = \"on-track\";\n        } else if (progress_delta_pct >= ATRISK_LOW) {\n            schedule_bucket = \"at-risk\";\n        } else {\n            schedule_bucket = \"delayed\";\n        }\n    }\n    // Task status (5 states)\n    let status;\n    let is_completed = false;\n    let is_overdue = false;\n    let is_stalled = false;\n    if (actual_finish || task.progress_pct !== null && task.progress_pct >= 100) {\n        status = \"completed\";\n        is_completed = true;\n    } else if (!actual_start && (task.progress_pct === null || task.progress_pct === 0)) {\n        status = \"not-started\";\n    } else if (planned_finish && today > planned_finish) {\n        status = \"overdue\";\n        is_overdue = true;\n    } else if (stale_update_flag && task.progress_pct !== null && task.progress_pct > 0) {\n        status = \"stalled\";\n        is_stalled = true;\n    } else {\n        status = \"in-progress\";\n    }\n    // Fallback: If schedule_bucket is still null but task is overdue/stalled, mark as delayed\n    if (schedule_bucket === null && (is_overdue || is_stalled)) {\n        schedule_bucket = \"delayed\";\n    } else if (schedule_bucket === null && is_completed) {\n        schedule_bucket = \"on-track\";\n    } else if (schedule_bucket === null && task.delay_flag_calc && task.delay_flag_calc.toUpperCase().includes(\"DELAY\")) {\n        schedule_bucket = \"delayed\";\n    } else if (schedule_bucket === null && status === \"in-progress\") {\n        schedule_bucket = \"on-track\";\n    }\n    // Slip days\n    let slip_days = 0;\n    if (status === \"completed\" && actual_finish && planned_finish) {\n        slip_days = Math.floor((actual_finish.getTime() - planned_finish.getTime()) / (1000 * 60 * 60 * 24));\n    } else if (is_overdue && planned_finish) {\n        slip_days = Math.floor((today.getTime() - planned_finish.getTime()) / (1000 * 60 * 60 * 24));\n    }\n    // Photo resolution\n    // const coverResult = resolvePhotoURL(task.cover_photo_direct_url, task.cover_photo_share_url);\n    const beforeResult = resolvePhotoURL(task.before_photo_direct_url, task.before_photo_share_url);\n    const afterResult = resolvePhotoURL(task.after_photo_direct_url, task.after_photo_share_url);\n    // Evidence status\n    const has_before = beforeResult.resolved !== null;\n    const has_after = afterResult.resolved !== null;\n    let evidence_status;\n    if (has_before && has_after) {\n        evidence_status = \"before-after\";\n    } else if (has_before) {\n        evidence_status = \"before-only\";\n    } else if (has_after) {\n        evidence_status = \"after-only\";\n    } else {\n        evidence_status = \"none\";\n    }\n    const evidence_compliant_flag = evidence_status === \"before-after\";\n    // Risk score\n    const missing_evidence = evidence_compliant_flag ? 0 : 1;\n    const risk_task = (is_overdue ? 50 : 0) + (stale_update_flag ? 20 : 0) + missing_evidence * 10 + Math.max(0, -(progress_delta_pct || 0));\n    // Legacy isDelayed flag (for backward compatibility)\n    const isDelayed = task.delay_flag_calc?.toUpperCase().includes(\"DELAY\") ?? false;\n    return {\n        ...task,\n        // Keys\n        site_uid,\n        task_uid,\n        siteKey,\n        // Status\n        status,\n        is_completed,\n        is_overdue,\n        is_stalled,\n        isDelayed,\n        // Schedule intelligence\n        planned_progress_pct,\n        progress_delta_pct,\n        schedule_bucket,\n        slip_days,\n        stale_update_flag,\n        // Weights\n        weight: task_weight_final,\n        task_weight_days,\n        task_weight_final,\n        task_weight_norm_site: 1,\n        // Photos\n        before_url_resolved: beforeResult.resolved,\n        after_url_resolved: afterResult.resolved,\n        before_photo_status: beforeResult.status,\n        after_photo_status: afterResult.status,\n        evidence_status,\n        evidence_compliant_flag,\n        // Quality\n        data_quality_issues: qualityReport.issues,\n        data_quality_flag: qualityReport.flag,\n        // Risk\n        risk_task,\n        // Reference\n        today_epoch\n    };\n}\n/**\n * Parse XLSX file and extract tasks from Data_Entry sheet\n */ async function parseXLSXFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                const data = new Uint8Array(e.target?.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_0__.read(data, {\n                    type: \"array\",\n                    cellDates: true\n                });\n                // Find Data_Entry sheet or use first sheet\n                let sheetName = \"Data_Entry\";\n                if (!workbook.SheetNames.includes(sheetName)) {\n                    sheetName = workbook.SheetNames[0];\n                    console.warn(`Sheet \"Data_Entry\" not found, using \"${sheetName}\"`);\n                }\n                const worksheet = workbook.Sheets[sheetName];\n                const rawData = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.sheet_to_json(worksheet, {\n                    raw: false,\n                    defval: null\n                });\n                // Parse and validate each row\n                const tasks = [];\n                if (rawData.length === 0) {\n                    reject(new Error(`No data found in sheet \"${sheetName}\"`));\n                    return;\n                }\n                console.log(`Found ${rawData.length} rows. First row keys:`, Object.keys(rawData[0] || {}));\n                for(let i = 0; i < rawData.length; i++){\n                    try {\n                        const rowData = rawData[i];\n                        // Skip empty rows\n                        if (!rowData.site_id && !rowData.package_id) {\n                            console.warn(`Row ${i + 2} skipped: missing site_id or package_id`);\n                            continue;\n                        }\n                        // Convert dates using DD-MM-YYYY parser\n                        const processedRow = {\n                            ...rowData,\n                            planned_start: parseDMY(rowData.planned_start),\n                            planned_finish: parseDMY(rowData.planned_finish),\n                            actual_start: parseDMY(rowData.actual_start),\n                            actual_finish: parseDMY(rowData.actual_finish),\n                            last_updated: parseDMY(rowData.last_updated),\n                            progress_pct: rowData.progress_pct != null ? Number(rowData.progress_pct) : null,\n                            planned_duration_days: rowData.planned_duration_days != null ? Number(rowData.planned_duration_days) : null,\n                            Variance: rowData.Variance != null ? Number(rowData.Variance) : null\n                        };\n                        const validated = _types__WEBPACK_IMPORTED_MODULE_3__.taskSchema.parse(processedRow);\n                        tasks.push(validated);\n                    } catch (err) {\n                        console.error(`Failed to parse row ${i + 2}:`, rawData[i], err);\n                    // Continue with other rows\n                    }\n                }\n                if (tasks.length === 0) {\n                    reject(new Error(\"No valid tasks could be parsed from the Excel file. Check column names and data format.\"));\n                    return;\n                }\n                console.log(`Successfully parsed ${tasks.length} tasks`);\n                resolve(tasks);\n            } catch (err) {\n                reject(err);\n            }\n        };\n        reader.onerror = ()=>reject(reader.error);\n        reader.readAsArrayBuffer(file);\n    });\n}\n/**\n * Clamp progress percentage\n */ function clampProgress(pct) {\n    if (pct === null) return 0;\n    return Math.max(0, Math.min(100, pct));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UTFGLFlBQVksSUFBSSxPQUFPNEYsT0FBT0YsUUFBUTFGLFlBQVksSUFBSTs0QkFDNUVHLHVCQUF1QnVGLFFBQVF2RixxQkFBcUIsSUFBSSxPQUFPeUYsT0FBT0YsUUFBUXZGLHFCQUFxQixJQUFJOzRCQUN2RzBGLFVBQVVILFFBQVFHLFFBQVEsSUFBSSxPQUFPRCxPQUFPRixRQUFRRyxRQUFRLElBQUk7d0JBQ2xFO3dCQUVBLE1BQU1DLFlBQVl2SSw4Q0FBVUEsQ0FBQ3dJLEtBQUssQ0FBQ0o7d0JBQ25DUCxNQUFNckYsSUFBSSxDQUFDK0Y7b0JBQ2IsRUFBRSxPQUFPRSxLQUFLO3dCQUNackIsUUFBUXNCLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixFQUFFUixJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUVWLE9BQU8sQ0FBQ1UsRUFBRSxFQUFFTztvQkFDM0QsMkJBQTJCO29CQUM3QjtnQkFDRjtnQkFFQSxJQUFJWixNQUFNbEcsTUFBTSxLQUFLLEdBQUc7b0JBQ3RCMEUsT0FBTyxJQUFJeUIsTUFBTTtvQkFDakI7Z0JBQ0Y7Z0JBRUFWLFFBQVFXLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFRixNQUFNbEcsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFDdkR5RSxRQUFReUI7WUFDVixFQUFFLE9BQU9ZLEtBQUs7Z0JBQ1pwQyxPQUFPb0M7WUFDVDtRQUNGO1FBRUFuQyxPQUFPcUMsT0FBTyxHQUFHLElBQU10QyxPQUFPQyxPQUFPb0MsS0FBSztRQUMxQ3BDLE9BQU9zQyxpQkFBaUIsQ0FBQzFDO0lBQzNCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVMyQyxjQUFjQyxHQUFrQjtJQUM5QyxJQUFJQSxRQUFRLE1BQU0sT0FBTztJQUN6QixPQUFPN0gsS0FBSzJDLEdBQUcsQ0FBQyxHQUFHM0MsS0FBSzhILEdBQUcsQ0FBQyxLQUFLRDtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb29kZGFzaGJvYXJkLy4vc3JjL2xpYi9kYXRhUGFyc2VyLnRzPzVlZWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4JztcbmltcG9ydCBkYXlqcyBmcm9tICdkYXlqcyc7XG5pbXBvcnQgY3VzdG9tUGFyc2VGb3JtYXQgZnJvbSAnZGF5anMvcGx1Z2luL2N1c3RvbVBhcnNlRm9ybWF0JztcbmltcG9ydCB7IHRhc2tTY2hlbWEsIFRhc2ssIFRhc2tXaXRoU3RhdHVzLCBUYXNrU3RhdHVzLCBTY2hlZHVsZUJ1Y2tldCwgRXZpZGVuY2VTdGF0dXMsIFBob3RvU3RhdHVzLCBRdWFsaXR5RmxhZyB9IGZyb20gJ0AvdHlwZXMnO1xuXG4vLyBFbmFibGUgc3RyaWN0IGRhdGUgcGFyc2luZ1xuZGF5anMuZXh0ZW5kKGN1c3RvbVBhcnNlRm9ybWF0KTtcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBTVEFMRV9EQVlTID0gMTQ7XG5jb25zdCBBSEVBRF9ERUxUQSA9IDEwO1xuY29uc3QgT05UUkFDS19MT1cgPSAtMTA7XG5jb25zdCBBVFJJU0tfTE9XID0gLTI1O1xuXG4vKipcbiAqIFBhcnNlIERELU1NLVlZWVkgb3IgREQvTU0vWVlZWSBkYXRlIHN0cmluZ3Mgc3RyaWN0bHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRE1ZKHZhbHVlOiB1bmtub3duKTogRGF0ZSB8IG51bGwge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gbnVsbDtcblxuICAvLyBIYW5kbGUgRXhjZWwgc2VyaWFsIGRhdGVzIChudW1iZXJzKVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBleGNlbERhdGVUb0pTRGF0ZSh2YWx1ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgZGF0ZSBvYmplY3RzXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBIYW5kbGUgc3RyaW5nIGRhdGVzXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RyID0gdmFsdWUudHJpbSgpO1xuXG4gICAgLy8gVHJ5IERELU1NLVlZWVkgZm9ybWF0IChzdHJpY3QpXG4gICAgbGV0IHBhcnNlZCA9IGRheWpzKHN0ciwgJ0RELU1NLVlZWVknLCB0cnVlKTtcbiAgICBpZiAocGFyc2VkLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZC50b0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgREQvTU0vWVlZWSBmb3JtYXQgKHN0cmljdClcbiAgICBwYXJzZWQgPSBkYXlqcyhzdHIsICdERC9NTS9ZWVlZJywgdHJ1ZSk7XG4gICAgaWYgKHBhcnNlZC5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBwYXJzZWQudG9EYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBwYXJzaW5nIChsZXNzIHN0cmljdClcbiAgICBwYXJzZWQgPSBkYXlqcyhzdHIpO1xuICAgIGlmIChwYXJzZWQuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gcGFyc2VkLnRvRGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvbnZlcnQgRXhjZWwgc2VyaWFsIGRhdGUgdG8gSlMgRGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhjZWxEYXRlVG9KU0RhdGUoc2VyaWFsOiBudW1iZXIgfCBzdHJpbmcgfCBEYXRlKTogRGF0ZSB8IG51bGwge1xuICBpZiAoc2VyaWFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHNlcmlhbDtcbiAgaWYgKCFzZXJpYWwpIHJldHVybiBudWxsO1xuXG4gIC8vIElmIGl0J3MgYSBzdHJpbmcsIHRyeSB0byBwYXJzZSBpdFxuICBpZiAodHlwZW9mIHNlcmlhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VETVkoc2VyaWFsKTtcbiAgfVxuXG4gIC8vIEV4Y2VsIHNlcmlhbCBkYXRlIChkYXlzIHNpbmNlIDE5MDAtMDEtMDEsIGJ1dCBFeGNlbCBpbmNvcnJlY3RseSB0cmVhdHMgMTkwMCBhcyBsZWFwIHllYXIpXG4gIGlmICh0eXBlb2Ygc2VyaWFsID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IHV0Y19kYXlzID0gTWF0aC5mbG9vcihzZXJpYWwgLSAyNTU2OSk7XG4gICAgY29uc3QgdXRjX3ZhbHVlID0gdXRjX2RheXMgKiA4NjQwMDtcbiAgICBjb25zdCBkYXRlX2luZm8gPSBuZXcgRGF0ZSh1dGNfdmFsdWUgKiAxMDAwKTtcbiAgICByZXR1cm4gZGF0ZV9pbmZvO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRXh0cmFjdCBHb29nbGUgRHJpdmUgZmlsZSBJRCBmcm9tIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdERyaXZlRmlsZSh1cmw6IHN0cmluZyB8IG51bGwpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCF1cmwpIHJldHVybiBudWxsO1xuXG4gIC8vIE1hdGNoOiAvZmlsZS9kLzxJRD4vIChkcml2ZS5nb29nbGUuY29tIG9yIGRvY3MuZ29vZ2xlLmNvbSlcbiAgbGV0IG1hdGNoID0gdXJsLm1hdGNoKC9cXC9maWxlXFwvZFxcLyhbLVxcd10rKS8pO1xuICBpZiAobWF0Y2gpIHJldHVybiBtYXRjaFsxXTtcblxuICAvLyBNYXRjaDogaWQ9PElEPiAoaW5jbHVkaW5nIG9wZW4/aWQ9IGFuZCB1Yz9pZD0pXG4gIG1hdGNoID0gdXJsLm1hdGNoKC9bPyZdaWQ9KFstXFx3XSspLyk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xuXG4gIC8vIE1hdGNoOiAvb3Blbj9pZD08SUQ+IChvbGRlciBzdHlsZSlcbiAgbWF0Y2ggPSB1cmwubWF0Y2goL1xcL29wZW5cXD9pZD0oWy1cXHddKykvKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV07XG5cbiAgLy8gTWF0Y2g6IC91Yz9pZD08SUQ+IChleHBvcnQgbGluaylcbiAgbWF0Y2ggPSB1cmwubWF0Y2goL1xcL3VjXFw/aWQ9KFstXFx3XSspLyk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlc29sdmUgR29vZ2xlIERyaXZlIFVSTHMgdG8gZGlyZWN0IGltYWdlIFVSTHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQaG90b1VSTChkaXJlY3RVcmw6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIHNoYXJlVXJsOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKToge1xuICByZXNvbHZlZDogc3RyaW5nIHwgbnVsbDtcbiAgc3RhdHVzOiBQaG90b1N0YXR1cztcbn0ge1xuICAvLyBQcmVmZXIgZGlyZWN0IFVSTFxuICBpZiAoZGlyZWN0VXJsICYmIGRpcmVjdFVybC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7IHJlc29sdmVkOiBkaXJlY3RVcmwsIHN0YXR1czogJ2RpcmVjdC1vaycgfTtcbiAgfVxuXG4gIC8vIFRyeSB0byBleHRyYWN0IGZpbGUgSUQgZnJvbSBzaGFyZSBVUkxcbiAgaWYgKHNoYXJlVXJsICYmIHNoYXJlVXJsLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlsZUlkID0gZXh0cmFjdERyaXZlRmlsZShzaGFyZVVybCk7XG4gICAgaWYgKGZpbGVJZCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSBgaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL3VjP2V4cG9ydD12aWV3JmlkPSR7ZmlsZUlkfWA7XG4gICAgICByZXR1cm4geyByZXNvbHZlZCwgc3RhdHVzOiAncmVzb2x2ZWQtZnJvbS1zaGFyZScgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVzb2x2ZWQ6IG51bGwsIHN0YXR1czogJ3VucmVzb2x2YWJsZScgfTtcbiAgfVxuXG4gIHJldHVybiB7IHJlc29sdmVkOiBudWxsLCBzdGF0dXM6ICdtaXNzaW5nJyB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRhc2sgZGF0YSBhbmQgcmV0dXJuIHF1YWxpdHkgaXNzdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRhc2tEYXRhKHRhc2s6IFRhc2ssIHBhcnNlZERhdGVzOiB7XG4gIHBsYW5uZWRfc3RhcnQ6IERhdGUgfCBudWxsO1xuICBwbGFubmVkX2ZpbmlzaDogRGF0ZSB8IG51bGw7XG4gIGFjdHVhbF9zdGFydDogRGF0ZSB8IG51bGw7XG4gIGFjdHVhbF9maW5pc2g6IERhdGUgfCBudWxsO1xuICBsYXN0X3VwZGF0ZWQ6IERhdGUgfCBudWxsO1xufSk6IHsgaXNzdWVzOiBzdHJpbmdbXTsgZmxhZzogUXVhbGl0eUZsYWcgfSB7XG4gIGNvbnN0IGlzc3Vlczogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdCB7IHBsYW5uZWRfc3RhcnQsIHBsYW5uZWRfZmluaXNoLCBhY3R1YWxfc3RhcnQsIGFjdHVhbF9maW5pc2gsIGxhc3RfdXBkYXRlZCB9ID0gcGFyc2VkRGF0ZXM7XG5cbiAgLy8gQ2hlY2s6IHBsYW5uZWQgZmluaXNoIGJlZm9yZSBzdGFydFxuICBpZiAocGxhbm5lZF9zdGFydCAmJiBwbGFubmVkX2ZpbmlzaCAmJiBwbGFubmVkX2ZpbmlzaCA8IHBsYW5uZWRfc3RhcnQpIHtcbiAgICBpc3N1ZXMucHVzaCgncGxhbm5lZF9maW5pc2hfYmVmb3JlX3N0YXJ0Jyk7XG4gIH1cblxuICAvLyBDaGVjazogYWN0dWFsIGZpbmlzaCBiZWZvcmUgc3RhcnRcbiAgaWYgKGFjdHVhbF9zdGFydCAmJiBhY3R1YWxfZmluaXNoICYmIGFjdHVhbF9maW5pc2ggPCBhY3R1YWxfc3RhcnQpIHtcbiAgICBpc3N1ZXMucHVzaCgnYWN0dWFsX2ZpbmlzaF9iZWZvcmVfc3RhcnQnKTtcbiAgfVxuXG4gIC8vIENoZWNrOiBwcm9ncmVzcyBvdXQgb2YgcmFuZ2UgKGFscmVhZHkgY2xhbXBlZCBpbiBzY2hlbWEsIGJ1dCBmbGFnIGl0KVxuICBpZiAodGFzay5wcm9ncmVzc19wY3QgIT09IG51bGwgJiYgKHRhc2sucHJvZ3Jlc3NfcGN0IDwgMCB8fCB0YXNrLnByb2dyZXNzX3BjdCA+IDEwMCkpIHtcbiAgICBpc3N1ZXMucHVzaCgncHJvZ3Jlc3Nfb3V0X29mX3JhbmdlJyk7XG4gIH1cblxuICAvLyBDaGVjazogY29tcGxldGVkIGJ1dCBtaXNzaW5nIGFjdHVhbF9maW5pc2hcbiAgaWYgKHRhc2sucHJvZ3Jlc3NfcGN0ICE9PSBudWxsICYmIHRhc2sucHJvZ3Jlc3NfcGN0ID49IDEwMCAmJiAhYWN0dWFsX2ZpbmlzaCkge1xuICAgIGlzc3Vlcy5wdXNoKCdjb21wbGV0ZWRfYnV0X21pc3NpbmdfYWN0dWFsX2ZpbmlzaCcpO1xuICB9XG5cbiAgLy8gQ2hlY2s6IG1pc3NpbmcgcGxhbm5lZCBkYXRlc1xuICBpZiAoIXBsYW5uZWRfc3RhcnQgfHwgIXBsYW5uZWRfZmluaXNoKSB7XG4gICAgaXNzdWVzLnB1c2goJ21pc3NpbmdfcGxhbm5lZF9kYXRlcycpO1xuICB9XG5cbiAgLy8gQ2hlY2s6IHN0YWxlIHVwZGF0ZVxuICBpZiAobGFzdF91cGRhdGVkKSB7XG4gICAgY29uc3QgZGF5c1NpbmNlVXBkYXRlID0gZGF5anMoKS5kaWZmKGRheWpzKGxhc3RfdXBkYXRlZCksICdkYXknKTtcbiAgICBpZiAoZGF5c1NpbmNlVXBkYXRlID4gU1RBTEVfREFZUykge1xuICAgICAgaXNzdWVzLnB1c2goJ3N0YWxlX3VwZGF0ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrOiBkdXJhdGlvbiBtaXNzaW5nIG9yIHplcm9cbiAgaWYgKHRhc2sucGxhbm5lZF9kdXJhdGlvbl9kYXlzID09PSBudWxsIHx8IHRhc2sucGxhbm5lZF9kdXJhdGlvbl9kYXlzIDw9IDApIHtcbiAgICBpc3N1ZXMucHVzaCgnZHVyYXRpb25fbWlzc2luZ19vcl96ZXJvJyk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgaGlnaGVzdCBzZXZlcml0eVxuICBsZXQgZmxhZzogUXVhbGl0eUZsYWcgPSBudWxsO1xuICBpZiAoaXNzdWVzLmluY2x1ZGVzKCdwbGFubmVkX2ZpbmlzaF9iZWZvcmVfc3RhcnQnKSB8fFxuICAgIGlzc3Vlcy5pbmNsdWRlcygnYWN0dWFsX2ZpbmlzaF9iZWZvcmVfc3RhcnQnKSB8fFxuICAgIGlzc3Vlcy5pbmNsdWRlcygncHJvZ3Jlc3Nfb3V0X29mX3JhbmdlJykpIHtcbiAgICBmbGFnID0gJ2NyaXRpY2FsJztcbiAgfSBlbHNlIGlmIChpc3N1ZXMuaW5jbHVkZXMoJ2NvbXBsZXRlZF9idXRfbWlzc2luZ19hY3R1YWxfZmluaXNoJykgfHxcbiAgICBpc3N1ZXMuaW5jbHVkZXMoJ21pc3NpbmdfcGxhbm5lZF9kYXRlcycpIHx8XG4gICAgaXNzdWVzLmluY2x1ZGVzKCdzdGFsZV91cGRhdGUnKSkge1xuICAgIGZsYWcgPSAnd2FybmluZyc7XG4gIH0gZWxzZSBpZiAoaXNzdWVzLmxlbmd0aCA+IDApIHtcbiAgICBmbGFnID0gJ2luZm8nO1xuICB9XG5cbiAgcmV0dXJuIHsgaXNzdWVzLCBmbGFnIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBzY2hlZHVsZSBpbnRlbGxpZ2VuY2UgYW5kIHN0YXR1cyBmb3IgYSB0YXNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVGFza1N0YXR1cyh0YXNrOiBUYXNrKTogVGFza1dpdGhTdGF0dXMge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IHRvZGF5X2Vwb2NoID0gdG9kYXkuZ2V0VGltZSgpO1xuXG4gIC8vIFBhcnNlIGRhdGVzIHVzaW5nIERELU1NLVlZWVkgcGFyc2VyXG4gIGNvbnN0IHBsYW5uZWRfc3RhcnQgPSBwYXJzZURNWSh0YXNrLnBsYW5uZWRfc3RhcnQpO1xuICBjb25zdCBwbGFubmVkX2ZpbmlzaCA9IHBhcnNlRE1ZKHRhc2sucGxhbm5lZF9maW5pc2gpO1xuICBjb25zdCBhY3R1YWxfc3RhcnQgPSBwYXJzZURNWSh0YXNrLmFjdHVhbF9zdGFydCk7XG4gIGNvbnN0IGFjdHVhbF9maW5pc2ggPSBwYXJzZURNWSh0YXNrLmFjdHVhbF9maW5pc2gpO1xuICBjb25zdCBsYXN0X3VwZGF0ZWQgPSBwYXJzZURNWSh0YXNrLmxhc3RfdXBkYXRlZCk7XG5cbiAgLy8gR2VuZXJhdGUgdW5pcXVlIGtleXNcbiAgY29uc3Qgc2l0ZV91aWQgPSBgJHt0YXNrLnBhY2thZ2VfaWR9fCR7dGFzay5kaXN0cmljdH18JHt0YXNrLnNpdGVfaWR9YDtcbiAgY29uc3QgdGFza191aWQgPSBgJHtzaXRlX3VpZH18JHt0YXNrLmRpc2NpcGxpbmV9fCR7dGFzay50YXNrX25hbWV9YDtcbiAgY29uc3Qgc2l0ZUtleSA9IGAke3Rhc2sucGFja2FnZV9pZH1fXyR7dGFzay5zaXRlX2lkfWA7IC8vIExlZ2FjeSBmb3JtYXRcblxuICAvLyBUYXNrIHdlaWdodFxuICBjb25zdCB0YXNrX3dlaWdodF9kYXlzID0gTWF0aC5tYXgoMSwgdGFzay5wbGFubmVkX2R1cmF0aW9uX2RheXMgfHwgMSk7XG4gIGNvbnN0IHRhc2tfd2VpZ2h0X2ZpbmFsID0gdGFza193ZWlnaHRfZGF5czsgLy8gQ2FuIGFkZCBvdmVycmlkZSBsb2dpYyBsYXRlclxuXG4gIC8vIFZhbGlkYXRlIGRhdGEgcXVhbGl0eVxuICBjb25zdCBxdWFsaXR5UmVwb3J0ID0gdmFsaWRhdGVUYXNrRGF0YSh0YXNrLCB7XG4gICAgcGxhbm5lZF9zdGFydCxcbiAgICBwbGFubmVkX2ZpbmlzaCxcbiAgICBhY3R1YWxfc3RhcnQsXG4gICAgYWN0dWFsX2ZpbmlzaCxcbiAgICBsYXN0X3VwZGF0ZWQsXG4gIH0pO1xuXG4gIC8vIFN0YWxlIHVwZGF0ZSBjaGVja1xuICBjb25zdCBzdGFsZV91cGRhdGVfZmxhZyA9IGxhc3RfdXBkYXRlZFxuICAgID8gZGF5anModG9kYXkpLmRpZmYoZGF5anMobGFzdF91cGRhdGVkKSwgJ2RheScpID4gU1RBTEVfREFZU1xuICAgIDogZmFsc2U7XG4gIC8vIENhbGN1bGF0ZSBwbGFubmVkIHByb2dyZXNzIChiYXNlbGluZSlcbiAgbGV0IHBsYW5uZWRfcHJvZ3Jlc3NfcGN0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgaWYgKHBsYW5uZWRfc3RhcnQgJiYgcGxhbm5lZF9maW5pc2gpIHtcbiAgICBjb25zdCBTID0gcGxhbm5lZF9zdGFydC5nZXRUaW1lKCk7XG4gICAgY29uc3QgRiA9IHBsYW5uZWRfZmluaXNoLmdldFRpbWUoKTtcbiAgICBjb25zdCBUID0gdG9kYXlfZXBvY2g7XG5cbiAgICBpZiAoVCA8PSBTKSB7XG4gICAgICBwbGFubmVkX3Byb2dyZXNzX3BjdCA9IDA7XG4gICAgfSBlbHNlIGlmIChUID49IEYpIHtcbiAgICAgIHBsYW5uZWRfcHJvZ3Jlc3NfcGN0ID0gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGFubmVkX3Byb2dyZXNzX3BjdCA9ICgoVCAtIFMpIC8gKEYgLSBTKSkgKiAxMDA7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJvZ3Jlc3MgZGVsdGFcbiAgY29uc3QgcHJvZ3Jlc3NfZGVsdGFfcGN0ID0gdGFzay5wcm9ncmVzc19wY3QgIT09IG51bGwgJiYgcGxhbm5lZF9wcm9ncmVzc19wY3QgIT09IG51bGxcbiAgICA/IHRhc2sucHJvZ3Jlc3NfcGN0IC0gcGxhbm5lZF9wcm9ncmVzc19wY3RcbiAgICA6IG51bGw7XG5cbiAgLy8gU2NoZWR1bGUgYnVja2V0XG4gIGxldCBzY2hlZHVsZV9idWNrZXQ6IFNjaGVkdWxlQnVja2V0IHwgbnVsbCA9IG51bGw7XG4gIGlmIChwcm9ncmVzc19kZWx0YV9wY3QgIT09IG51bGwpIHtcbiAgICBpZiAocHJvZ3Jlc3NfZGVsdGFfcGN0ID4gQUhFQURfREVMVEEpIHtcbiAgICAgIHNjaGVkdWxlX2J1Y2tldCA9ICdhaGVhZCc7XG4gICAgfSBlbHNlIGlmIChwcm9ncmVzc19kZWx0YV9wY3QgPj0gT05UUkFDS19MT1cpIHtcbiAgICAgIHNjaGVkdWxlX2J1Y2tldCA9ICdvbi10cmFjayc7XG4gICAgfSBlbHNlIGlmIChwcm9ncmVzc19kZWx0YV9wY3QgPj0gQVRSSVNLX0xPVykge1xuICAgICAgc2NoZWR1bGVfYnVja2V0ID0gJ2F0LXJpc2snO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZV9idWNrZXQgPSAnZGVsYXllZCc7XG4gICAgfVxuICB9XG5cbiAgLy8gVGFzayBzdGF0dXMgKDUgc3RhdGVzKVxuICBsZXQgc3RhdHVzOiBUYXNrU3RhdHVzO1xuICBsZXQgaXNfY29tcGxldGVkID0gZmFsc2U7XG4gIGxldCBpc19vdmVyZHVlID0gZmFsc2U7XG4gIGxldCBpc19zdGFsbGVkID0gZmFsc2U7XG5cbiAgaWYgKGFjdHVhbF9maW5pc2ggfHwgKHRhc2sucHJvZ3Jlc3NfcGN0ICE9PSBudWxsICYmIHRhc2sucHJvZ3Jlc3NfcGN0ID49IDEwMCkpIHtcbiAgICBzdGF0dXMgPSAnY29tcGxldGVkJztcbiAgICBpc19jb21wbGV0ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFhY3R1YWxfc3RhcnQgJiYgKHRhc2sucHJvZ3Jlc3NfcGN0ID09PSBudWxsIHx8IHRhc2sucHJvZ3Jlc3NfcGN0ID09PSAwKSkge1xuICAgIHN0YXR1cyA9ICdub3Qtc3RhcnRlZCc7XG4gIH0gZWxzZSBpZiAocGxhbm5lZF9maW5pc2ggJiYgdG9kYXkgPiBwbGFubmVkX2ZpbmlzaCkge1xuICAgIHN0YXR1cyA9ICdvdmVyZHVlJztcbiAgICBpc19vdmVyZHVlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFsZV91cGRhdGVfZmxhZyAmJiB0YXNrLnByb2dyZXNzX3BjdCAhPT0gbnVsbCAmJiB0YXNrLnByb2dyZXNzX3BjdCA+IDApIHtcbiAgICBzdGF0dXMgPSAnc3RhbGxlZCc7XG4gICAgaXNfc3RhbGxlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdHVzID0gJ2luLXByb2dyZXNzJztcbiAgfVxuXG4gIC8vIEZhbGxiYWNrOiBJZiBzY2hlZHVsZV9idWNrZXQgaXMgc3RpbGwgbnVsbCBidXQgdGFzayBpcyBvdmVyZHVlL3N0YWxsZWQsIG1hcmsgYXMgZGVsYXllZFxuICBpZiAoc2NoZWR1bGVfYnVja2V0ID09PSBudWxsICYmIChpc19vdmVyZHVlIHx8IGlzX3N0YWxsZWQpKSB7XG4gICAgc2NoZWR1bGVfYnVja2V0ID0gJ2RlbGF5ZWQnO1xuICB9XG4gIC8vIElmIHRhc2sgaXMgY29tcGxldGVkIGJ1dCBubyBzY2hlZHVsZV9idWNrZXQsIG1hcmsgYXMgb24tdHJhY2tcbiAgZWxzZSBpZiAoc2NoZWR1bGVfYnVja2V0ID09PSBudWxsICYmIGlzX2NvbXBsZXRlZCkge1xuICAgIHNjaGVkdWxlX2J1Y2tldCA9ICdvbi10cmFjayc7XG4gIH1cbiAgLy8gTkVXOiBJZiBubyBzY2hlZHVsZV9idWNrZXQgYnV0IHRhc2sgaGFzIGRlbGF5IGZsYWcgZnJvbSBzcHJlYWRzaGVldCwgdXNlIHRoYXRcbiAgZWxzZSBpZiAoc2NoZWR1bGVfYnVja2V0ID09PSBudWxsICYmIHRhc2suZGVsYXlfZmxhZ19jYWxjICYmIHRhc2suZGVsYXlfZmxhZ19jYWxjLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0RFTEFZJykpIHtcbiAgICBzY2hlZHVsZV9idWNrZXQgPSAnZGVsYXllZCc7XG4gIH1cbiAgLy8gSWYgdGFzayBpcyBpbiBwcm9ncmVzcyBidXQgbm8gc2NoZWR1bGUgZGF0YSwgbWFyayBhcyBvbi10cmFja1xuICBlbHNlIGlmIChzY2hlZHVsZV9idWNrZXQgPT09IG51bGwgJiYgc3RhdHVzID09PSAnaW4tcHJvZ3Jlc3MnKSB7XG4gICAgc2NoZWR1bGVfYnVja2V0ID0gJ29uLXRyYWNrJztcbiAgfVxuXG4gIC8vIFNsaXAgZGF5c1xuICBsZXQgc2xpcF9kYXlzID0gMDtcbiAgaWYgKHN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiYgYWN0dWFsX2ZpbmlzaCAmJiBwbGFubmVkX2ZpbmlzaCkge1xuICAgIHNsaXBfZGF5cyA9IE1hdGguZmxvb3IoKGFjdHVhbF9maW5pc2guZ2V0VGltZSgpIC0gcGxhbm5lZF9maW5pc2guZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gIH0gZWxzZSBpZiAoaXNfb3ZlcmR1ZSAmJiBwbGFubmVkX2ZpbmlzaCkge1xuICAgIHNsaXBfZGF5cyA9IE1hdGguZmxvb3IoKHRvZGF5LmdldFRpbWUoKSAtIHBsYW5uZWRfZmluaXNoLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICB9XG5cbiAgLy8gUGhvdG8gcmVzb2x1dGlvblxuICAvLyBjb25zdCBjb3ZlclJlc3VsdCA9IHJlc29sdmVQaG90b1VSTCh0YXNrLmNvdmVyX3Bob3RvX2RpcmVjdF91cmwsIHRhc2suY292ZXJfcGhvdG9fc2hhcmVfdXJsKTtcbiAgY29uc3QgYmVmb3JlUmVzdWx0ID0gcmVzb2x2ZVBob3RvVVJMKHRhc2suYmVmb3JlX3Bob3RvX2RpcmVjdF91cmwsIHRhc2suYmVmb3JlX3Bob3RvX3NoYXJlX3VybCk7XG4gIGNvbnN0IGFmdGVyUmVzdWx0ID0gcmVzb2x2ZVBob3RvVVJMKHRhc2suYWZ0ZXJfcGhvdG9fZGlyZWN0X3VybCwgdGFzay5hZnRlcl9waG90b19zaGFyZV91cmwpO1xuXG4gIC8vIEV2aWRlbmNlIHN0YXR1c1xuICBjb25zdCBoYXNfYmVmb3JlID0gYmVmb3JlUmVzdWx0LnJlc29sdmVkICE9PSBudWxsO1xuICBjb25zdCBoYXNfYWZ0ZXIgPSBhZnRlclJlc3VsdC5yZXNvbHZlZCAhPT0gbnVsbDtcbiAgbGV0IGV2aWRlbmNlX3N0YXR1czogRXZpZGVuY2VTdGF0dXM7XG4gIGlmIChoYXNfYmVmb3JlICYmIGhhc19hZnRlcikge1xuICAgIGV2aWRlbmNlX3N0YXR1cyA9ICdiZWZvcmUtYWZ0ZXInO1xuICB9IGVsc2UgaWYgKGhhc19iZWZvcmUpIHtcbiAgICBldmlkZW5jZV9zdGF0dXMgPSAnYmVmb3JlLW9ubHknO1xuICB9IGVsc2UgaWYgKGhhc19hZnRlcikge1xuICAgIGV2aWRlbmNlX3N0YXR1cyA9ICdhZnRlci1vbmx5JztcbiAgfSBlbHNlIHtcbiAgICBldmlkZW5jZV9zdGF0dXMgPSAnbm9uZSc7XG4gIH1cblxuICBjb25zdCBldmlkZW5jZV9jb21wbGlhbnRfZmxhZyA9IGV2aWRlbmNlX3N0YXR1cyA9PT0gJ2JlZm9yZS1hZnRlcic7XG5cbiAgLy8gUmlzayBzY29yZVxuICBjb25zdCBtaXNzaW5nX2V2aWRlbmNlID0gZXZpZGVuY2VfY29tcGxpYW50X2ZsYWcgPyAwIDogMTtcbiAgY29uc3Qgcmlza190YXNrID1cbiAgICAoaXNfb3ZlcmR1ZSA/IDUwIDogMCkgK1xuICAgIChzdGFsZV91cGRhdGVfZmxhZyA/IDIwIDogMCkgK1xuICAgIChtaXNzaW5nX2V2aWRlbmNlICogMTApICtcbiAgICBNYXRoLm1heCgwLCAtKHByb2dyZXNzX2RlbHRhX3BjdCB8fCAwKSk7XG5cbiAgLy8gTGVnYWN5IGlzRGVsYXllZCBmbGFnIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgY29uc3QgaXNEZWxheWVkID0gdGFzay5kZWxheV9mbGFnX2NhbGM/LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0RFTEFZJykgPz8gZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi50YXNrLFxuICAgIC8vIEtleXNcbiAgICBzaXRlX3VpZCxcbiAgICB0YXNrX3VpZCxcbiAgICBzaXRlS2V5LFxuXG4gICAgLy8gU3RhdHVzXG4gICAgc3RhdHVzLFxuICAgIGlzX2NvbXBsZXRlZCxcbiAgICBpc19vdmVyZHVlLFxuICAgIGlzX3N0YWxsZWQsXG4gICAgaXNEZWxheWVkLFxuXG4gICAgLy8gU2NoZWR1bGUgaW50ZWxsaWdlbmNlXG4gICAgcGxhbm5lZF9wcm9ncmVzc19wY3QsXG4gICAgcHJvZ3Jlc3NfZGVsdGFfcGN0LFxuICAgIHNjaGVkdWxlX2J1Y2tldCxcbiAgICBzbGlwX2RheXMsXG4gICAgc3RhbGVfdXBkYXRlX2ZsYWcsXG5cbiAgICAvLyBXZWlnaHRzXG4gICAgd2VpZ2h0OiB0YXNrX3dlaWdodF9maW5hbCwgLy8gTGVnYWN5XG4gICAgdGFza193ZWlnaHRfZGF5cyxcbiAgICB0YXNrX3dlaWdodF9maW5hbCxcbiAgICB0YXNrX3dlaWdodF9ub3JtX3NpdGU6IDEsIC8vIFdpbGwgYmUgbm9ybWFsaXplZCBsYXRlciBwZXIgc2l0ZVxuXG4gICAgLy8gUGhvdG9zXG4gICAgYmVmb3JlX3VybF9yZXNvbHZlZDogYmVmb3JlUmVzdWx0LnJlc29sdmVkLFxuICAgIGFmdGVyX3VybF9yZXNvbHZlZDogYWZ0ZXJSZXN1bHQucmVzb2x2ZWQsXG4gICAgYmVmb3JlX3Bob3RvX3N0YXR1czogYmVmb3JlUmVzdWx0LnN0YXR1cyxcbiAgICBhZnRlcl9waG90b19zdGF0dXM6IGFmdGVyUmVzdWx0LnN0YXR1cyxcbiAgICBldmlkZW5jZV9zdGF0dXMsXG4gICAgZXZpZGVuY2VfY29tcGxpYW50X2ZsYWcsXG5cbiAgICAvLyBRdWFsaXR5XG4gICAgZGF0YV9xdWFsaXR5X2lzc3VlczogcXVhbGl0eVJlcG9ydC5pc3N1ZXMsXG4gICAgZGF0YV9xdWFsaXR5X2ZsYWc6IHF1YWxpdHlSZXBvcnQuZmxhZyxcblxuICAgIC8vIFJpc2tcbiAgICByaXNrX3Rhc2ssXG5cbiAgICAvLyBSZWZlcmVuY2VcbiAgICB0b2RheV9lcG9jaCxcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBYTFNYIGZpbGUgYW5kIGV4dHJhY3QgdGFza3MgZnJvbSBEYXRhX0VudHJ5IHNoZWV0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVhMU1hGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPFRhc2tbXT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShlLnRhcmdldD8ucmVzdWx0IGFzIEFycmF5QnVmZmVyKTtcbiAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoZGF0YSwgeyB0eXBlOiAnYXJyYXknLCBjZWxsRGF0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gRmluZCBEYXRhX0VudHJ5IHNoZWV0IG9yIHVzZSBmaXJzdCBzaGVldFxuICAgICAgICBsZXQgc2hlZXROYW1lID0gJ0RhdGFfRW50cnknO1xuICAgICAgICBpZiAoIXdvcmtib29rLlNoZWV0TmFtZXMuaW5jbHVkZXMoc2hlZXROYW1lKSkge1xuICAgICAgICAgIHNoZWV0TmFtZSA9IHdvcmtib29rLlNoZWV0TmFtZXNbMF07XG4gICAgICAgICAgY29uc29sZS53YXJuKGBTaGVldCBcIkRhdGFfRW50cnlcIiBub3QgZm91bmQsIHVzaW5nIFwiJHtzaGVldE5hbWV9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVdO1xuICAgICAgICBjb25zdCByYXdEYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwge1xuICAgICAgICAgIHJhdzogZmFsc2UsXG4gICAgICAgICAgZGVmdmFsOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQYXJzZSBhbmQgdmFsaWRhdGUgZWFjaCByb3dcbiAgICAgICAgY29uc3QgdGFza3M6IFRhc2tbXSA9IFtdO1xuXG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vIGRhdGEgZm91bmQgaW4gc2hlZXQgXCIke3NoZWV0TmFtZX1cImApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtyYXdEYXRhLmxlbmd0aH0gcm93cy4gRmlyc3Qgcm93IGtleXM6YCwgT2JqZWN0LmtleXMocmF3RGF0YVswXSB8fCB7fSkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0gcmF3RGF0YVtpXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSByb3dzXG4gICAgICAgICAgICBpZiAoIXJvd0RhdGEuc2l0ZV9pZCAmJiAhcm93RGF0YS5wYWNrYWdlX2lkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUm93ICR7aSArIDJ9IHNraXBwZWQ6IG1pc3Npbmcgc2l0ZV9pZCBvciBwYWNrYWdlX2lkYCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGVzIHVzaW5nIERELU1NLVlZWVkgcGFyc2VyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRSb3cgPSB7XG4gICAgICAgICAgICAgIC4uLnJvd0RhdGEsXG4gICAgICAgICAgICAgIHBsYW5uZWRfc3RhcnQ6IHBhcnNlRE1ZKHJvd0RhdGEucGxhbm5lZF9zdGFydCBhcyBzdHJpbmcgfCBudW1iZXIgfCBEYXRlKSxcbiAgICAgICAgICAgICAgcGxhbm5lZF9maW5pc2g6IHBhcnNlRE1ZKHJvd0RhdGEucGxhbm5lZF9maW5pc2ggYXMgc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSksXG4gICAgICAgICAgICAgIGFjdHVhbF9zdGFydDogcGFyc2VETVkocm93RGF0YS5hY3R1YWxfc3RhcnQgYXMgc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSksXG4gICAgICAgICAgICAgIGFjdHVhbF9maW5pc2g6IHBhcnNlRE1ZKHJvd0RhdGEuYWN0dWFsX2ZpbmlzaCBhcyBzdHJpbmcgfCBudW1iZXIgfCBEYXRlKSxcbiAgICAgICAgICAgICAgbGFzdF91cGRhdGVkOiBwYXJzZURNWShyb3dEYXRhLmxhc3RfdXBkYXRlZCBhcyBzdHJpbmcgfCBudW1iZXIgfCBEYXRlKSxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NfcGN0OiByb3dEYXRhLnByb2dyZXNzX3BjdCAhPSBudWxsID8gTnVtYmVyKHJvd0RhdGEucHJvZ3Jlc3NfcGN0KSA6IG51bGwsXG4gICAgICAgICAgICAgIHBsYW5uZWRfZHVyYXRpb25fZGF5czogcm93RGF0YS5wbGFubmVkX2R1cmF0aW9uX2RheXMgIT0gbnVsbCA/IE51bWJlcihyb3dEYXRhLnBsYW5uZWRfZHVyYXRpb25fZGF5cykgOiBudWxsLFxuICAgICAgICAgICAgICBWYXJpYW5jZTogcm93RGF0YS5WYXJpYW5jZSAhPSBudWxsID8gTnVtYmVyKHJvd0RhdGEuVmFyaWFuY2UpIDogbnVsbCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZCA9IHRhc2tTY2hlbWEucGFyc2UocHJvY2Vzc2VkUm93KTtcbiAgICAgICAgICAgIHRhc2tzLnB1c2godmFsaWRhdGVkKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSByb3cgJHtpICsgMn06YCwgcmF3RGF0YVtpXSwgZXJyKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgcm93c1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdObyB2YWxpZCB0YXNrcyBjb3VsZCBiZSBwYXJzZWQgZnJvbSB0aGUgRXhjZWwgZmlsZS4gQ2hlY2sgY29sdW1uIG5hbWVzIGFuZCBkYXRhIGZvcm1hdC4nKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBwYXJzZWQgJHt0YXNrcy5sZW5ndGh9IHRhc2tzYCk7XG4gICAgICAgIHJlc29sdmUodGFza3MpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2xhbXAgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXBQcm9ncmVzcyhwY3Q6IG51bWJlciB8IG51bGwpOiBudW1iZXIge1xuICBpZiAocGN0ID09PSBudWxsKSByZXR1cm4gMDtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcGN0KSk7XG59XG4iXSwibmFtZXMiOlsiWExTWCIsImRheWpzIiwiY3VzdG9tUGFyc2VGb3JtYXQiLCJ0YXNrU2NoZW1hIiwiZXh0ZW5kIiwiU1RBTEVfREFZUyIsIkFIRUFEX0RFTFRBIiwiT05UUkFDS19MT1ciLCJBVFJJU0tfTE9XIiwicGFyc2VETVkiLCJ2YWx1ZSIsImV4Y2VsRGF0ZVRvSlNEYXRlIiwiRGF0ZSIsInN0ciIsInRyaW0iLCJwYXJzZWQiLCJpc1ZhbGlkIiwidG9EYXRlIiwic2VyaWFsIiwidXRjX2RheXMiLCJNYXRoIiwiZmxvb3IiLCJ1dGNfdmFsdWUiLCJkYXRlX2luZm8iLCJleHRyYWN0RHJpdmVGaWxlIiwidXJsIiwibWF0Y2giLCJyZXNvbHZlUGhvdG9VUkwiLCJkaXJlY3RVcmwiLCJzaGFyZVVybCIsImxlbmd0aCIsInJlc29sdmVkIiwic3RhdHVzIiwiZmlsZUlkIiwidmFsaWRhdGVUYXNrRGF0YSIsInRhc2siLCJwYXJzZWREYXRlcyIsImlzc3VlcyIsInBsYW5uZWRfc3RhcnQiLCJwbGFubmVkX2ZpbmlzaCIsImFjdHVhbF9zdGFydCIsImFjdHVhbF9maW5pc2giLCJsYXN0X3VwZGF0ZWQiLCJwdXNoIiwicHJvZ3Jlc3NfcGN0IiwiZGF5c1NpbmNlVXBkYXRlIiwiZGlmZiIsInBsYW5uZWRfZHVyYXRpb25fZGF5cyIsImZsYWciLCJpbmNsdWRlcyIsImNvbXB1dGVUYXNrU3RhdHVzIiwidG9kYXkiLCJ0b2RheV9lcG9jaCIsImdldFRpbWUiLCJzaXRlX3VpZCIsInBhY2thZ2VfaWQiLCJkaXN0cmljdCIsInNpdGVfaWQiLCJ0YXNrX3VpZCIsImRpc2NpcGxpbmUiLCJ0YXNrX25hbWUiLCJzaXRlS2V5IiwidGFza193ZWlnaHRfZGF5cyIsIm1heCIsInRhc2tfd2VpZ2h0X2ZpbmFsIiwicXVhbGl0eVJlcG9ydCIsInN0YWxlX3VwZGF0ZV9mbGFnIiwicGxhbm5lZF9wcm9ncmVzc19wY3QiLCJTIiwiRiIsIlQiLCJwcm9ncmVzc19kZWx0YV9wY3QiLCJzY2hlZHVsZV9idWNrZXQiLCJpc19jb21wbGV0ZWQiLCJpc19vdmVyZHVlIiwiaXNfc3RhbGxlZCIsImRlbGF5X2ZsYWdfY2FsYyIsInRvVXBwZXJDYXNlIiwic2xpcF9kYXlzIiwiYmVmb3JlUmVzdWx0IiwiYmVmb3JlX3Bob3RvX2RpcmVjdF91cmwiLCJiZWZvcmVfcGhvdG9fc2hhcmVfdXJsIiwiYWZ0ZXJSZXN1bHQiLCJhZnRlcl9waG90b19kaXJlY3RfdXJsIiwiYWZ0ZXJfcGhvdG9fc2hhcmVfdXJsIiwiaGFzX2JlZm9yZSIsImhhc19hZnRlciIsImV2aWRlbmNlX3N0YXR1cyIsImV2aWRlbmNlX2NvbXBsaWFudF9mbGFnIiwibWlzc2luZ19ldmlkZW5jZSIsInJpc2tfdGFzayIsImlzRGVsYXllZCIsIndlaWdodCIsInRhc2tfd2VpZ2h0X25vcm1fc2l0ZSIsImJlZm9yZV91cmxfcmVzb2x2ZWQiLCJhZnRlcl91cmxfcmVzb2x2ZWQiLCJiZWZvcmVfcGhvdG9fc3RhdHVzIiwiYWZ0ZXJfcGhvdG9fc3RhdHVzIiwiZGF0YV9xdWFsaXR5X2lzc3VlcyIsImRhdGFfcXVhbGl0eV9mbGFnIiwicGFyc2VYTFNYRmlsZSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJ0YXJnZXQiLCJyZXN1bHQiLCJ3b3JrYm9vayIsInJlYWQiLCJ0eXBlIiwiY2VsbERhdGVzIiwic2hlZXROYW1lIiwiU2hlZXROYW1lcyIsImNvbnNvbGUiLCJ3YXJuIiwid29ya3NoZWV0IiwiU2hlZXRzIiwicmF3RGF0YSIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsInJhdyIsImRlZnZhbCIsInRhc2tzIiwiRXJyb3IiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwiaSIsInJvd0RhdGEiLCJwcm9jZXNzZWRSb3ciLCJOdW1iZXIiLCJWYXJpYW5jZSIsInZhbGlkYXRlZCIsInBhcnNlIiwiZXJyIiwiZXJyb3IiLCJvbmVycm9yIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJjbGFtcFByb2dyZXNzIiwicGN0IiwibWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/lib/dataParser.ts\n");

/***/ }),

/***/ "(api)/./src/lib/dataProcessor.ts":
/*!**********************************!*\
  !*** ./src/lib/dataProcessor.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyFilters: () => (/* binding */ applyFilters),\n/* harmony export */   computeKPIs: () => (/* binding */ computeKPIs),\n/* harmony export */   getFilterOptions: () => (/* binding */ getFilterOptions),\n/* harmony export */   groupTasksBySite: () => (/* binding */ groupTasksBySite),\n/* harmony export */   normalizeSiteWeights: () => (/* binding */ normalizeSiteWeights)\n/* harmony export */ });\n/**\n * Normalize task weights per site (so they sum to 1.0)\n */ function normalizeSiteWeights(tasks) {\n    const siteWeights = new Map();\n    // Calculate total weight per site\n    for (const task of tasks){\n        const siteKey = task.site_uid || task.siteKey;\n        const currentTotal = siteWeights.get(siteKey) || 0;\n        siteWeights.set(siteKey, currentTotal + task.task_weight_final);\n    }\n    // Normalize weights\n    return tasks.map((task)=>{\n        const siteKey = task.site_uid || task.siteKey;\n        const siteTotal = siteWeights.get(siteKey) || 1;\n        return {\n            ...task,\n            task_weight_norm_site: task.task_weight_final / siteTotal\n        };\n    });\n}\n/**\n * Group tasks by site\n */ function groupTasksBySite(tasks) {\n    const siteMap = new Map();\n    for (const task of tasks){\n        const existing = siteMap.get(task.siteKey) || [];\n        existing.push(task);\n        siteMap.set(task.siteKey, existing);\n    }\n    const sites = [];\n    for (const [siteKey, siteTasks] of siteMap.entries()){\n        const firstTask = siteTasks[0];\n        // Compute weighted progress\n        // CRITICAL FIX: Tasks with null progress MUST be included with 0% progress\n        // BUG WAS: if (task.progress_pct !== null) excluded tasks from denominator\n        let totalWeightedProgress = 0;\n        let totalWeight = 0;\n        // Debug logging for specific site\n        const isDebugSite = firstTask.site_name === \"BHU Islampura\";\n        if (isDebugSite) {\n            console.log(\"\\n=== DEBUG: Site Progress Calculation ===\");\n            console.log(`Site: ${firstTask.site_name} (${siteKey})`);\n            console.log(`Total tasks in site: ${siteTasks.length}`);\n        }\n        for (const task of siteTasks){\n            // CRITICAL: Treat null/undefined progress as 0, NOT exclude the task\n            const progress = task.progress_pct ?? 0;\n            const weight = task.weight || 1; // Fallback weight if missing\n            totalWeightedProgress += progress * weight;\n            totalWeight += weight;\n            if (isDebugSite) {\n                console.log(`  Task: ${task.task_name}`);\n                console.log(`    - progress_pct (raw): ${task.progress_pct}`);\n                console.log(`    - progress (used): ${progress}`);\n                console.log(`    - weight: ${weight}`);\n                console.log(`    - contribution: ${progress * weight}`);\n            }\n        }\n        // Calculate final weighted progress\n        // Safety: clamp between 0 and 100, handle zero-task edge case\n        let weightedProgress = totalWeight > 0 ? totalWeightedProgress / totalWeight : 0;\n        weightedProgress = Math.max(0, Math.min(100, weightedProgress));\n        if (isDebugSite) {\n            console.log(`\\n  CALCULATION:`);\n            console.log(`    - totalWeightedProgress (numerator): ${totalWeightedProgress}`);\n            console.log(`    - totalWeight (denominator): ${totalWeight}`);\n            console.log(`    - weightedProgress (final): ${weightedProgress.toFixed(2)}%`);\n            console.log(\"=== END DEBUG ===\\n\");\n        }\n        // Count statuses\n        const completedTasks = siteTasks.filter((t)=>t.status === \"completed\").length;\n        const inProgressTasks = siteTasks.filter((t)=>t.status === \"in-progress\").length;\n        const notStartedTasks = siteTasks.filter((t)=>t.status === \"not-started\").length;\n        const delayedTasks = siteTasks.filter((t)=>t.isDelayed).length;\n        // Risk score: weighted sum of task risk scores\n        let totalWeightedRisk = 0;\n        let totalRiskWeight = 0;\n        for (const task of siteTasks){\n            totalWeightedRisk += task.risk_task * task.task_weight_norm_site;\n            totalRiskWeight += task.task_weight_norm_site;\n        }\n        const riskScore = totalRiskWeight > 0 ? totalWeightedRisk / totalRiskWeight : 0;\n        const riskLevel = riskScore >= 40 ? \"high\" : riskScore >= 20 ? \"medium\" : \"low\";\n        // Get max dates\n        const plannedFinishes = siteTasks.map((t)=>t.planned_finish).filter((d)=>d !== null);\n        const maxPlannedFinish = plannedFinishes.length > 0 ? new Date(Math.max(...plannedFinishes.map((d)=>d.getTime()))) : null;\n        const lastUpdates = siteTasks.map((t)=>t.last_updated).filter((d)=>d !== null);\n        const maxLastUpdated = lastUpdates.length > 0 ? new Date(Math.max(...lastUpdates.map((d)=>d.getTime()))) : null;\n        // Get photo URLs (prefer from first task, or find first non-null)\n        const coverPhotoDirectUrl = siteTasks.find((t)=>t.cover_photo_direct_url)?.cover_photo_direct_url || null;\n        const photoFolderUrl = siteTasks.find((t)=>t.photo_folder_url)?.photo_folder_url || null;\n        const coverPhotoShareUrl = siteTasks.find((t)=>t.cover_photo_share_url)?.cover_photo_share_url || null;\n        sites.push({\n            siteKey,\n            package_id: firstTask.package_id,\n            package_name: firstTask.package_name,\n            district: firstTask.district,\n            site_id: firstTask.site_id,\n            site_name: firstTask.site_name,\n            tasks: siteTasks,\n            totalTasks: siteTasks.length,\n            completedTasks,\n            inProgressTasks,\n            notStartedTasks,\n            delayedTasks,\n            weightedProgress,\n            riskScore,\n            riskLevel,\n            maxPlannedFinish,\n            maxLastUpdated,\n            coverPhotoDirectUrl,\n            photoFolderUrl,\n            coverPhotoShareUrl\n        });\n    }\n    return sites;\n}\n/**\n * Compute overall KPIs\n */ function computeKPIs(tasks) {\n    const uniqueSites = new Set(tasks.map((t)=>t.siteKey));\n    // Site-level aggregates for site KPIs\n    const siteStatus = new Map();\n    tasks.forEach((t)=>{\n        const entry = siteStatus.get(t.siteKey) || {\n            total: 0,\n            completed: 0\n        };\n        entry.total += 1;\n        if (t.status === \"completed\") entry.completed += 1;\n        siteStatus.set(t.siteKey, entry);\n    });\n    // Weighted progress (same fix as site progress)\n    let totalWeightedProgress = 0;\n    let totalWeight = 0;\n    for (const task of tasks){\n        // CRITICAL FIX: Treat null progress as 0, NOT exclude\n        const progress = task.progress_pct ?? 0;\n        const weight = task.weight || 1;\n        totalWeightedProgress += progress * weight;\n        totalWeight += task.weight;\n    }\n    let overallWeightedProgress = totalWeight > 0 ? totalWeightedProgress / totalWeight : 0;\n    overallWeightedProgress = Math.max(0, Math.min(100, overallWeightedProgress));\n    const sitesWithCompleted = Array.from(siteStatus.values()).filter((s)=>s.completed > 0).length;\n    const sitesFullyCompleted = Array.from(siteStatus.values()).filter((s)=>s.completed === s.total && s.total > 0).length;\n    return {\n        totalSites: uniqueSites.size,\n        totalTasks: tasks.length,\n        overallWeightedProgress,\n        sitesWithCompleted,\n        sitesFullyCompleted,\n        delayedTasks: tasks.filter((t)=>t.isDelayed).length,\n        notStartedTasks: tasks.filter((t)=>t.status === \"not-started\").length,\n        inProgressTasks: tasks.filter((t)=>t.status === \"in-progress\").length,\n        completedTasks: tasks.filter((t)=>t.status === \"completed\").length\n    };\n}\n/**\n * Apply filters to tasks\n */ function applyFilters(tasks, filters) {\n    let filtered = tasks;\n    // Package names\n    if (filters.packageNames.length > 0) {\n        filtered = filtered.filter((t)=>filters.packageNames.includes(t.package_name));\n    }\n    // Districts\n    if (filters.districts.length > 0) {\n        filtered = filtered.filter((t)=>filters.districts.includes(t.district));\n    }\n    // Site name search\n    if (filters.siteNameSearch.trim()) {\n        const search = filters.siteNameSearch.toLowerCase();\n        filtered = filtered.filter((t)=>t.site_name.toLowerCase().includes(search) || t.site_id.toLowerCase().includes(search));\n    }\n    // Disciplines\n    if (filters.disciplines.length > 0) {\n        filtered = filtered.filter((t)=>filters.disciplines.includes(t.discipline));\n    }\n    // Delay flags\n    if (filters.delayFlags.length > 0) {\n        filtered = filtered.filter((t)=>t.delay_flag_calc && filters.delayFlags.includes(t.delay_flag_calc));\n    }\n    // Date range\n    if (filters.dateRangeStart) {\n        filtered = filtered.filter((t)=>t.planned_start && t.planned_start >= filters.dateRangeStart);\n    }\n    if (filters.dateRangeEnd) {\n        filtered = filtered.filter((t)=>t.planned_finish && t.planned_finish <= filters.dateRangeEnd);\n    }\n    // Show only delayed\n    if (filters.showOnlyDelayed) {\n        filtered = filtered.filter((t)=>t.isDelayed);\n    }\n    return filtered;\n}\n/**\n * Get unique values for filter options\n */ function getFilterOptions(tasks) {\n    const packageNames = Array.from(new Set(tasks.map((t)=>t.package_name))).sort();\n    const districts = Array.from(new Set(tasks.map((t)=>t.district))).sort();\n    const disciplines = Array.from(new Set(tasks.map((t)=>t.discipline))).sort();\n    const delayFlags = Array.from(new Set(tasks.map((t)=>t.delay_flag_calc).filter((d)=>d !== null))).sort();\n    return {\n        packageNames,\n        districts,\n        disciplines,\n        delayFlags\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvbGliL2RhdGFQcm9jZXNzb3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQTs7Q0FFQyxHQUNNLFNBQVNBLHFCQUFxQkMsS0FBdUI7SUFDMUQsTUFBTUMsY0FBYyxJQUFJQztJQUV4QixrQ0FBa0M7SUFDbEMsS0FBSyxNQUFNQyxRQUFRSCxNQUFPO1FBQ3hCLE1BQU1JLFVBQVVELEtBQUtFLFFBQVEsSUFBSUYsS0FBS0MsT0FBTztRQUM3QyxNQUFNRSxlQUFlTCxZQUFZTSxHQUFHLENBQUNILFlBQVk7UUFDakRILFlBQVlPLEdBQUcsQ0FBQ0osU0FBU0UsZUFBZUgsS0FBS00saUJBQWlCO0lBQ2hFO0lBRUEsb0JBQW9CO0lBQ3BCLE9BQU9ULE1BQU1VLEdBQUcsQ0FBQ1AsQ0FBQUE7UUFDZixNQUFNQyxVQUFVRCxLQUFLRSxRQUFRLElBQUlGLEtBQUtDLE9BQU87UUFDN0MsTUFBTU8sWUFBWVYsWUFBWU0sR0FBRyxDQUFDSCxZQUFZO1FBQzlDLE9BQU87WUFDTCxHQUFHRCxJQUFJO1lBQ1BTLHVCQUF1QlQsS0FBS00saUJBQWlCLEdBQUdFO1FBQ2xEO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0UsaUJBQWlCYixLQUF1QjtJQUN0RCxNQUFNYyxVQUFVLElBQUlaO0lBRXBCLEtBQUssTUFBTUMsUUFBUUgsTUFBTztRQUN4QixNQUFNZSxXQUFXRCxRQUFRUCxHQUFHLENBQUNKLEtBQUtDLE9BQU8sS0FBSyxFQUFFO1FBQ2hEVyxTQUFTQyxJQUFJLENBQUNiO1FBQ2RXLFFBQVFOLEdBQUcsQ0FBQ0wsS0FBS0MsT0FBTyxFQUFFVztJQUM1QjtJQUVBLE1BQU1FLFFBQXlCLEVBQUU7SUFFakMsS0FBSyxNQUFNLENBQUNiLFNBQVNjLFVBQVUsSUFBSUosUUFBUUssT0FBTyxHQUFJO1FBQ3BELE1BQU1DLFlBQVlGLFNBQVMsQ0FBQyxFQUFFO1FBRTlCLDRCQUE0QjtRQUM1QiwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLElBQUlHLHdCQUF3QjtRQUM1QixJQUFJQyxjQUFjO1FBRWxCLGtDQUFrQztRQUNsQyxNQUFNQyxjQUFjSCxVQUFVSSxTQUFTLEtBQUs7UUFDNUMsSUFBSUQsYUFBYTtZQUNmRSxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFTixVQUFVSSxTQUFTLENBQUMsRUFBRSxFQUFFcEIsUUFBUSxDQUFDLENBQUM7WUFDdkRxQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRVIsVUFBVVMsTUFBTSxDQUFDLENBQUM7UUFDeEQ7UUFFQSxLQUFLLE1BQU14QixRQUFRZSxVQUFXO1lBQzVCLHFFQUFxRTtZQUNyRSxNQUFNVSxXQUFXekIsS0FBSzBCLFlBQVksSUFBSTtZQUN0QyxNQUFNQyxTQUFTM0IsS0FBSzJCLE1BQU0sSUFBSSxHQUFHLDZCQUE2QjtZQUU5RFQseUJBQXlCTyxXQUFXRTtZQUNwQ1IsZUFBZVE7WUFFZixJQUFJUCxhQUFhO2dCQUNmRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUV2QixLQUFLNEIsU0FBUyxDQUFDLENBQUM7Z0JBQ3ZDTixRQUFRQyxHQUFHLENBQUMsQ0FBQywwQkFBMEIsRUFBRXZCLEtBQUswQixZQUFZLENBQUMsQ0FBQztnQkFDNURKLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFRSxTQUFTLENBQUM7Z0JBQ2hESCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUVJLE9BQU8sQ0FBQztnQkFDckNMLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFRSxXQUFXRSxPQUFPLENBQUM7WUFDeEQ7UUFDRjtRQUVBLG9DQUFvQztRQUNwQyw4REFBOEQ7UUFDOUQsSUFBSUUsbUJBQW1CVixjQUFjLElBQUlELHdCQUF3QkMsY0FBYztRQUMvRVUsbUJBQW1CQyxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtIO1FBRTdDLElBQUlULGFBQWE7WUFDZkUsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7WUFDOUJELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlDQUF5QyxFQUFFTCxzQkFBc0IsQ0FBQztZQUMvRUksUUFBUUMsR0FBRyxDQUFDLENBQUMsaUNBQWlDLEVBQUVKLFlBQVksQ0FBQztZQUM3REcsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0NBQWdDLEVBQUVNLGlCQUFpQkksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzdFWCxRQUFRQyxHQUFHLENBQUM7UUFDZDtRQUVBLGlCQUFpQjtRQUNqQixNQUFNVyxpQkFBaUJuQixVQUFVb0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssYUFBYWIsTUFBTTtRQUM3RSxNQUFNYyxrQkFBa0J2QixVQUFVb0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssZUFBZWIsTUFBTTtRQUNoRixNQUFNZSxrQkFBa0J4QixVQUFVb0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssZUFBZWIsTUFBTTtRQUNoRixNQUFNZ0IsZUFBZXpCLFVBQVVvQixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLFNBQVMsRUFBRWpCLE1BQU07UUFFOUQsK0NBQStDO1FBQy9DLElBQUlrQixvQkFBb0I7UUFDeEIsSUFBSUMsa0JBQWtCO1FBRXRCLEtBQUssTUFBTTNDLFFBQVFlLFVBQVc7WUFDNUIyQixxQkFBcUIxQyxLQUFLNEMsU0FBUyxHQUFHNUMsS0FBS1MscUJBQXFCO1lBQ2hFa0MsbUJBQW1CM0MsS0FBS1MscUJBQXFCO1FBQy9DO1FBRUEsTUFBTW9DLFlBQVlGLGtCQUFrQixJQUFJRCxvQkFBb0JDLGtCQUFrQjtRQUM5RSxNQUFNRyxZQUNKRCxhQUFhLEtBQUssU0FBU0EsYUFBYSxLQUFLLFdBQVc7UUFFMUQsZ0JBQWdCO1FBQ2hCLE1BQU1FLGtCQUFrQmhDLFVBQ3JCUixHQUFHLENBQUM2QixDQUFBQSxJQUFLQSxFQUFFWSxjQUFjLEVBQ3pCYixNQUFNLENBQUMsQ0FBQ2MsSUFBaUJBLE1BQU07UUFDbEMsTUFBTUMsbUJBQW1CSCxnQkFBZ0J2QixNQUFNLEdBQUcsSUFDOUMsSUFBSTJCLEtBQUtyQixLQUFLQyxHQUFHLElBQUlnQixnQkFBZ0J4QyxHQUFHLENBQUMwQyxDQUFBQSxJQUFLQSxFQUFFRyxPQUFPLFFBQ3ZEO1FBRUosTUFBTUMsY0FBY3RDLFVBQ2pCUixHQUFHLENBQUM2QixDQUFBQSxJQUFLQSxFQUFFa0IsWUFBWSxFQUN2Qm5CLE1BQU0sQ0FBQyxDQUFDYyxJQUFpQkEsTUFBTTtRQUNsQyxNQUFNTSxpQkFBaUJGLFlBQVk3QixNQUFNLEdBQUcsSUFDeEMsSUFBSTJCLEtBQUtyQixLQUFLQyxHQUFHLElBQUlzQixZQUFZOUMsR0FBRyxDQUFDMEMsQ0FBQUEsSUFBS0EsRUFBRUcsT0FBTyxRQUNuRDtRQUVKLGtFQUFrRTtRQUNsRSxNQUFNSSxzQkFBc0J6QyxVQUFVMEMsSUFBSSxDQUFDckIsQ0FBQUEsSUFBS0EsRUFBRXNCLHNCQUFzQixHQUFHQSwwQkFBMEI7UUFDckcsTUFBTUMsaUJBQWlCNUMsVUFBVTBDLElBQUksQ0FBQ3JCLENBQUFBLElBQUtBLEVBQUV3QixnQkFBZ0IsR0FBR0Esb0JBQW9CO1FBQ3BGLE1BQU1DLHFCQUFxQjlDLFVBQVUwQyxJQUFJLENBQUNyQixDQUFBQSxJQUFLQSxFQUFFMEIscUJBQXFCLEdBQUdBLHlCQUF5QjtRQUVsR2hELE1BQU1ELElBQUksQ0FBQztZQUNUWjtZQUNBOEQsWUFBWTlDLFVBQVU4QyxVQUFVO1lBQ2hDQyxjQUFjL0MsVUFBVStDLFlBQVk7WUFDcENDLFVBQVVoRCxVQUFVZ0QsUUFBUTtZQUM1QkMsU0FBU2pELFVBQVVpRCxPQUFPO1lBQzFCN0MsV0FBV0osVUFBVUksU0FBUztZQUM5QnhCLE9BQU9rQjtZQUNQb0QsWUFBWXBELFVBQVVTLE1BQU07WUFDNUJVO1lBQ0FJO1lBQ0FDO1lBQ0FDO1lBQ0FYO1lBQ0FnQjtZQUNBQztZQUNBSTtZQUNBSztZQUNBQztZQUNBRztZQUNBRTtRQUNGO0lBQ0Y7SUFFQSxPQUFPL0M7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU3NELFlBQVl2RSxLQUF1QjtJQUNqRCxNQUFNd0UsY0FBYyxJQUFJQyxJQUFJekUsTUFBTVUsR0FBRyxDQUFDNkIsQ0FBQUEsSUFBS0EsRUFBRW5DLE9BQU87SUFFcEQsc0NBQXNDO0lBQ3RDLE1BQU1zRSxhQUFhLElBQUl4RTtJQUN2QkYsTUFBTTJFLE9BQU8sQ0FBQ3BDLENBQUFBO1FBQ1osTUFBTXFDLFFBQVFGLFdBQVduRSxHQUFHLENBQUNnQyxFQUFFbkMsT0FBTyxLQUFLO1lBQUV5RSxPQUFPO1lBQUdDLFdBQVc7UUFBRTtRQUNwRUYsTUFBTUMsS0FBSyxJQUFJO1FBQ2YsSUFBSXRDLEVBQUVDLE1BQU0sS0FBSyxhQUFhb0MsTUFBTUUsU0FBUyxJQUFJO1FBQ2pESixXQUFXbEUsR0FBRyxDQUFDK0IsRUFBRW5DLE9BQU8sRUFBRXdFO0lBQzVCO0lBRUEsZ0RBQWdEO0lBQ2hELElBQUl2RCx3QkFBd0I7SUFDNUIsSUFBSUMsY0FBYztJQUVsQixLQUFLLE1BQU1uQixRQUFRSCxNQUFPO1FBQ3hCLHNEQUFzRDtRQUN0RCxNQUFNNEIsV0FBV3pCLEtBQUswQixZQUFZLElBQUk7UUFDdEMsTUFBTUMsU0FBUzNCLEtBQUsyQixNQUFNLElBQUk7UUFFOUJULHlCQUF5Qk8sV0FBV0U7UUFDcENSLGVBQWVuQixLQUFLMkIsTUFBTTtJQUM1QjtJQUVBLElBQUlpRCwwQkFBMEJ6RCxjQUFjLElBQUlELHdCQUF3QkMsY0FBYztJQUN0RnlELDBCQUEwQjlDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBSzRDO0lBRXBELE1BQU1DLHFCQUFxQkMsTUFBTUMsSUFBSSxDQUFDUixXQUFXUyxNQUFNLElBQUk3QyxNQUFNLENBQUM4QyxDQUFBQSxJQUFLQSxFQUFFTixTQUFTLEdBQUcsR0FBR25ELE1BQU07SUFDOUYsTUFBTTBELHNCQUFzQkosTUFBTUMsSUFBSSxDQUFDUixXQUFXUyxNQUFNLElBQUk3QyxNQUFNLENBQUM4QyxDQUFBQSxJQUFLQSxFQUFFTixTQUFTLEtBQUtNLEVBQUVQLEtBQUssSUFBSU8sRUFBRVAsS0FBSyxHQUFHLEdBQUdsRCxNQUFNO0lBRXRILE9BQU87UUFDTDJELFlBQVlkLFlBQVllLElBQUk7UUFDNUJqQixZQUFZdEUsTUFBTTJCLE1BQU07UUFDeEJvRDtRQUNBQztRQUNBSztRQUNBMUMsY0FBYzNDLE1BQU1zQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLFNBQVMsRUFBRWpCLE1BQU07UUFDbkRlLGlCQUFpQjFDLE1BQU1zQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxlQUFlYixNQUFNO1FBQ3JFYyxpQkFBaUJ6QyxNQUFNc0MsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssZUFBZWIsTUFBTTtRQUNyRVUsZ0JBQWdCckMsTUFBTXNDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLGFBQWFiLE1BQU07SUFDcEU7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzZELGFBQWF4RixLQUF1QixFQUFFeUYsT0FBb0I7SUFDeEUsSUFBSUMsV0FBVzFGO0lBRWYsZ0JBQWdCO0lBQ2hCLElBQUl5RixRQUFRRSxZQUFZLENBQUNoRSxNQUFNLEdBQUcsR0FBRztRQUNuQytELFdBQVdBLFNBQVNwRCxNQUFNLENBQUNDLENBQUFBLElBQUtrRCxRQUFRRSxZQUFZLENBQUNDLFFBQVEsQ0FBQ3JELEVBQUU0QixZQUFZO0lBQzlFO0lBRUEsWUFBWTtJQUNaLElBQUlzQixRQUFRSSxTQUFTLENBQUNsRSxNQUFNLEdBQUcsR0FBRztRQUNoQytELFdBQVdBLFNBQVNwRCxNQUFNLENBQUNDLENBQUFBLElBQUtrRCxRQUFRSSxTQUFTLENBQUNELFFBQVEsQ0FBQ3JELEVBQUU2QixRQUFRO0lBQ3ZFO0lBRUEsbUJBQW1CO0lBQ25CLElBQUlxQixRQUFRSyxjQUFjLENBQUNDLElBQUksSUFBSTtRQUNqQyxNQUFNQyxTQUFTUCxRQUFRSyxjQUFjLENBQUNHLFdBQVc7UUFDakRQLFdBQVdBLFNBQVNwRCxNQUFNLENBQUNDLENBQUFBLElBQ3pCQSxFQUFFZixTQUFTLENBQUN5RSxXQUFXLEdBQUdMLFFBQVEsQ0FBQ0ksV0FDbkN6RCxFQUFFOEIsT0FBTyxDQUFDNEIsV0FBVyxHQUFHTCxRQUFRLENBQUNJO0lBRXJDO0lBRUEsY0FBYztJQUNkLElBQUlQLFFBQVFTLFdBQVcsQ0FBQ3ZFLE1BQU0sR0FBRyxHQUFHO1FBQ2xDK0QsV0FBV0EsU0FBU3BELE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS2tELFFBQVFTLFdBQVcsQ0FBQ04sUUFBUSxDQUFDckQsRUFBRTRELFVBQVU7SUFDM0U7SUFFQSxjQUFjO0lBQ2QsSUFBSVYsUUFBUVcsVUFBVSxDQUFDekUsTUFBTSxHQUFHLEdBQUc7UUFDakMrRCxXQUFXQSxTQUFTcEQsTUFBTSxDQUFDQyxDQUFBQSxJQUN6QkEsRUFBRThELGVBQWUsSUFBSVosUUFBUVcsVUFBVSxDQUFDUixRQUFRLENBQUNyRCxFQUFFOEQsZUFBZTtJQUV0RTtJQUVBLGFBQWE7SUFDYixJQUFJWixRQUFRYSxjQUFjLEVBQUU7UUFDMUJaLFdBQVdBLFNBQVNwRCxNQUFNLENBQUNDLENBQUFBLElBQ3pCQSxFQUFFZ0UsYUFBYSxJQUFJaEUsRUFBRWdFLGFBQWEsSUFBSWQsUUFBUWEsY0FBYztJQUVoRTtJQUNBLElBQUliLFFBQVFlLFlBQVksRUFBRTtRQUN4QmQsV0FBV0EsU0FBU3BELE1BQU0sQ0FBQ0MsQ0FBQUEsSUFDekJBLEVBQUVZLGNBQWMsSUFBSVosRUFBRVksY0FBYyxJQUFJc0MsUUFBUWUsWUFBWTtJQUVoRTtJQUVBLG9CQUFvQjtJQUNwQixJQUFJZixRQUFRZ0IsZUFBZSxFQUFFO1FBQzNCZixXQUFXQSxTQUFTcEQsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSyxTQUFTO0lBQzdDO0lBRUEsT0FBTzhDO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNnQixpQkFBaUIxRyxLQUF1QjtJQUN0RCxNQUFNMkYsZUFBZVYsTUFBTUMsSUFBSSxDQUFDLElBQUlULElBQUl6RSxNQUFNVSxHQUFHLENBQUM2QixDQUFBQSxJQUFLQSxFQUFFNEIsWUFBWSxJQUFJd0MsSUFBSTtJQUM3RSxNQUFNZCxZQUFZWixNQUFNQyxJQUFJLENBQUMsSUFBSVQsSUFBSXpFLE1BQU1VLEdBQUcsQ0FBQzZCLENBQUFBLElBQUtBLEVBQUU2QixRQUFRLElBQUl1QyxJQUFJO0lBQ3RFLE1BQU1ULGNBQWNqQixNQUFNQyxJQUFJLENBQUMsSUFBSVQsSUFBSXpFLE1BQU1VLEdBQUcsQ0FBQzZCLENBQUFBLElBQUtBLEVBQUU0RCxVQUFVLElBQUlRLElBQUk7SUFDMUUsTUFBTVAsYUFBYW5CLE1BQU1DLElBQUksQ0FDM0IsSUFBSVQsSUFBSXpFLE1BQU1VLEdBQUcsQ0FBQzZCLENBQUFBLElBQUtBLEVBQUU4RCxlQUFlLEVBQUUvRCxNQUFNLENBQUMsQ0FBQ2MsSUFBbUJBLE1BQU0sUUFDM0V1RCxJQUFJO0lBRU4sT0FBTztRQUFFaEI7UUFBY0U7UUFBV0s7UUFBYUU7SUFBVztBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb29kZGFzaGJvYXJkLy4vc3JjL2xpYi9kYXRhUHJvY2Vzc29yLnRzPzRjODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFza1dpdGhTdGF0dXMsIFNpdGVBZ2dyZWdhdGUsIERhc2hib2FyZEtQSXMsIEZpbHRlclN0YXRlIH0gZnJvbSAnQC90eXBlcyc7XG5cbi8qKlxuICogTm9ybWFsaXplIHRhc2sgd2VpZ2h0cyBwZXIgc2l0ZSAoc28gdGhleSBzdW0gdG8gMS4wKVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU2l0ZVdlaWdodHModGFza3M6IFRhc2tXaXRoU3RhdHVzW10pOiBUYXNrV2l0aFN0YXR1c1tdIHtcbiAgY29uc3Qgc2l0ZVdlaWdodHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCB3ZWlnaHQgcGVyIHNpdGVcbiAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgY29uc3Qgc2l0ZUtleSA9IHRhc2suc2l0ZV91aWQgfHwgdGFzay5zaXRlS2V5O1xuICAgIGNvbnN0IGN1cnJlbnRUb3RhbCA9IHNpdGVXZWlnaHRzLmdldChzaXRlS2V5KSB8fCAwO1xuICAgIHNpdGVXZWlnaHRzLnNldChzaXRlS2V5LCBjdXJyZW50VG90YWwgKyB0YXNrLnRhc2tfd2VpZ2h0X2ZpbmFsKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzXG4gIHJldHVybiB0YXNrcy5tYXAodGFzayA9PiB7XG4gICAgY29uc3Qgc2l0ZUtleSA9IHRhc2suc2l0ZV91aWQgfHwgdGFzay5zaXRlS2V5O1xuICAgIGNvbnN0IHNpdGVUb3RhbCA9IHNpdGVXZWlnaHRzLmdldChzaXRlS2V5KSB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICAuLi50YXNrLFxuICAgICAgdGFza193ZWlnaHRfbm9ybV9zaXRlOiB0YXNrLnRhc2tfd2VpZ2h0X2ZpbmFsIC8gc2l0ZVRvdGFsLFxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyb3VwIHRhc2tzIGJ5IHNpdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwVGFza3NCeVNpdGUodGFza3M6IFRhc2tXaXRoU3RhdHVzW10pOiBTaXRlQWdncmVnYXRlW10ge1xuICBjb25zdCBzaXRlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFRhc2tXaXRoU3RhdHVzW10+KCk7XG5cbiAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzaXRlTWFwLmdldCh0YXNrLnNpdGVLZXkpIHx8IFtdO1xuICAgIGV4aXN0aW5nLnB1c2godGFzayk7XG4gICAgc2l0ZU1hcC5zZXQodGFzay5zaXRlS2V5LCBleGlzdGluZyk7XG4gIH1cblxuICBjb25zdCBzaXRlczogU2l0ZUFnZ3JlZ2F0ZVtdID0gW107XG5cbiAgZm9yIChjb25zdCBbc2l0ZUtleSwgc2l0ZVRhc2tzXSBvZiBzaXRlTWFwLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGZpcnN0VGFzayA9IHNpdGVUYXNrc1swXTtcblxuICAgIC8vIENvbXB1dGUgd2VpZ2h0ZWQgcHJvZ3Jlc3NcbiAgICAvLyBDUklUSUNBTCBGSVg6IFRhc2tzIHdpdGggbnVsbCBwcm9ncmVzcyBNVVNUIGJlIGluY2x1ZGVkIHdpdGggMCUgcHJvZ3Jlc3NcbiAgICAvLyBCVUcgV0FTOiBpZiAodGFzay5wcm9ncmVzc19wY3QgIT09IG51bGwpIGV4Y2x1ZGVkIHRhc2tzIGZyb20gZGVub21pbmF0b3JcbiAgICBsZXQgdG90YWxXZWlnaHRlZFByb2dyZXNzID0gMDtcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAgLy8gRGVidWcgbG9nZ2luZyBmb3Igc3BlY2lmaWMgc2l0ZVxuICAgIGNvbnN0IGlzRGVidWdTaXRlID0gZmlyc3RUYXNrLnNpdGVfbmFtZSA9PT0gJ0JIVSBJc2xhbXB1cmEnO1xuICAgIGlmIChpc0RlYnVnU2l0ZSkge1xuICAgICAgY29uc29sZS5sb2coJ1xcbj09PSBERUJVRzogU2l0ZSBQcm9ncmVzcyBDYWxjdWxhdGlvbiA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKGBTaXRlOiAke2ZpcnN0VGFzay5zaXRlX25hbWV9ICgke3NpdGVLZXl9KWApO1xuICAgICAgY29uc29sZS5sb2coYFRvdGFsIHRhc2tzIGluIHNpdGU6ICR7c2l0ZVRhc2tzLmxlbmd0aH1gKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHRhc2sgb2Ygc2l0ZVRhc2tzKSB7XG4gICAgICAvLyBDUklUSUNBTDogVHJlYXQgbnVsbC91bmRlZmluZWQgcHJvZ3Jlc3MgYXMgMCwgTk9UIGV4Y2x1ZGUgdGhlIHRhc2tcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gdGFzay5wcm9ncmVzc19wY3QgPz8gMDtcbiAgICAgIGNvbnN0IHdlaWdodCA9IHRhc2sud2VpZ2h0IHx8IDE7IC8vIEZhbGxiYWNrIHdlaWdodCBpZiBtaXNzaW5nXG5cbiAgICAgIHRvdGFsV2VpZ2h0ZWRQcm9ncmVzcyArPSBwcm9ncmVzcyAqIHdlaWdodDtcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcblxuICAgICAgaWYgKGlzRGVidWdTaXRlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIFRhc2s6ICR7dGFzay50YXNrX25hbWV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAgLSBwcm9ncmVzc19wY3QgKHJhdyk6ICR7dGFzay5wcm9ncmVzc19wY3R9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAgLSBwcm9ncmVzcyAodXNlZCk6ICR7cHJvZ3Jlc3N9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAgLSB3ZWlnaHQ6ICR7d2VpZ2h0fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgIC0gY29udHJpYnV0aW9uOiAke3Byb2dyZXNzICogd2VpZ2h0fWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBmaW5hbCB3ZWlnaHRlZCBwcm9ncmVzc1xuICAgIC8vIFNhZmV0eTogY2xhbXAgYmV0d2VlbiAwIGFuZCAxMDAsIGhhbmRsZSB6ZXJvLXRhc2sgZWRnZSBjYXNlXG4gICAgbGV0IHdlaWdodGVkUHJvZ3Jlc3MgPSB0b3RhbFdlaWdodCA+IDAgPyB0b3RhbFdlaWdodGVkUHJvZ3Jlc3MgLyB0b3RhbFdlaWdodCA6IDA7XG4gICAgd2VpZ2h0ZWRQcm9ncmVzcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgd2VpZ2h0ZWRQcm9ncmVzcykpO1xuXG4gICAgaWYgKGlzRGVidWdTaXRlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgXFxuICBDQUxDVUxBVElPTjpgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICAgLSB0b3RhbFdlaWdodGVkUHJvZ3Jlc3MgKG51bWVyYXRvcik6ICR7dG90YWxXZWlnaHRlZFByb2dyZXNzfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgICAtIHRvdGFsV2VpZ2h0IChkZW5vbWluYXRvcik6ICR7dG90YWxXZWlnaHR9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgIC0gd2VpZ2h0ZWRQcm9ncmVzcyAoZmluYWwpOiAke3dlaWdodGVkUHJvZ3Jlc3MudG9GaXhlZCgyKX0lYCk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEVORCBERUJVRyA9PT1cXG4nKTtcbiAgICB9XG5cbiAgICAvLyBDb3VudCBzdGF0dXNlc1xuICAgIGNvbnN0IGNvbXBsZXRlZFRhc2tzID0gc2l0ZVRhc2tzLmZpbHRlcih0ID0+IHQuc3RhdHVzID09PSAnY29tcGxldGVkJykubGVuZ3RoO1xuICAgIGNvbnN0IGluUHJvZ3Jlc3NUYXNrcyA9IHNpdGVUYXNrcy5maWx0ZXIodCA9PiB0LnN0YXR1cyA9PT0gJ2luLXByb2dyZXNzJykubGVuZ3RoO1xuICAgIGNvbnN0IG5vdFN0YXJ0ZWRUYXNrcyA9IHNpdGVUYXNrcy5maWx0ZXIodCA9PiB0LnN0YXR1cyA9PT0gJ25vdC1zdGFydGVkJykubGVuZ3RoO1xuICAgIGNvbnN0IGRlbGF5ZWRUYXNrcyA9IHNpdGVUYXNrcy5maWx0ZXIodCA9PiB0LmlzRGVsYXllZCkubGVuZ3RoO1xuXG4gICAgLy8gUmlzayBzY29yZTogd2VpZ2h0ZWQgc3VtIG9mIHRhc2sgcmlzayBzY29yZXNcbiAgICBsZXQgdG90YWxXZWlnaHRlZFJpc2sgPSAwO1xuICAgIGxldCB0b3RhbFJpc2tXZWlnaHQgPSAwO1xuXG4gICAgZm9yIChjb25zdCB0YXNrIG9mIHNpdGVUYXNrcykge1xuICAgICAgdG90YWxXZWlnaHRlZFJpc2sgKz0gdGFzay5yaXNrX3Rhc2sgKiB0YXNrLnRhc2tfd2VpZ2h0X25vcm1fc2l0ZTtcbiAgICAgIHRvdGFsUmlza1dlaWdodCArPSB0YXNrLnRhc2tfd2VpZ2h0X25vcm1fc2l0ZTtcbiAgICB9XG5cbiAgICBjb25zdCByaXNrU2NvcmUgPSB0b3RhbFJpc2tXZWlnaHQgPiAwID8gdG90YWxXZWlnaHRlZFJpc2sgLyB0b3RhbFJpc2tXZWlnaHQgOiAwO1xuICAgIGNvbnN0IHJpc2tMZXZlbDogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyA9XG4gICAgICByaXNrU2NvcmUgPj0gNDAgPyAnaGlnaCcgOiByaXNrU2NvcmUgPj0gMjAgPyAnbWVkaXVtJyA6ICdsb3cnO1xuXG4gICAgLy8gR2V0IG1heCBkYXRlc1xuICAgIGNvbnN0IHBsYW5uZWRGaW5pc2hlcyA9IHNpdGVUYXNrc1xuICAgICAgLm1hcCh0ID0+IHQucGxhbm5lZF9maW5pc2gpXG4gICAgICAuZmlsdGVyKChkKTogZCBpcyBEYXRlID0+IGQgIT09IG51bGwpO1xuICAgIGNvbnN0IG1heFBsYW5uZWRGaW5pc2ggPSBwbGFubmVkRmluaXNoZXMubGVuZ3RoID4gMFxuICAgICAgPyBuZXcgRGF0ZShNYXRoLm1heCguLi5wbGFubmVkRmluaXNoZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGNvbnN0IGxhc3RVcGRhdGVzID0gc2l0ZVRhc2tzXG4gICAgICAubWFwKHQgPT4gdC5sYXN0X3VwZGF0ZWQpXG4gICAgICAuZmlsdGVyKChkKTogZCBpcyBEYXRlID0+IGQgIT09IG51bGwpO1xuICAgIGNvbnN0IG1heExhc3RVcGRhdGVkID0gbGFzdFVwZGF0ZXMubGVuZ3RoID4gMFxuICAgICAgPyBuZXcgRGF0ZShNYXRoLm1heCguLi5sYXN0VXBkYXRlcy5tYXAoZCA9PiBkLmdldFRpbWUoKSkpKVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gR2V0IHBob3RvIFVSTHMgKHByZWZlciBmcm9tIGZpcnN0IHRhc2ssIG9yIGZpbmQgZmlyc3Qgbm9uLW51bGwpXG4gICAgY29uc3QgY292ZXJQaG90b0RpcmVjdFVybCA9IHNpdGVUYXNrcy5maW5kKHQgPT4gdC5jb3Zlcl9waG90b19kaXJlY3RfdXJsKT8uY292ZXJfcGhvdG9fZGlyZWN0X3VybCB8fCBudWxsO1xuICAgIGNvbnN0IHBob3RvRm9sZGVyVXJsID0gc2l0ZVRhc2tzLmZpbmQodCA9PiB0LnBob3RvX2ZvbGRlcl91cmwpPy5waG90b19mb2xkZXJfdXJsIHx8IG51bGw7XG4gICAgY29uc3QgY292ZXJQaG90b1NoYXJlVXJsID0gc2l0ZVRhc2tzLmZpbmQodCA9PiB0LmNvdmVyX3Bob3RvX3NoYXJlX3VybCk/LmNvdmVyX3Bob3RvX3NoYXJlX3VybCB8fCBudWxsO1xuXG4gICAgc2l0ZXMucHVzaCh7XG4gICAgICBzaXRlS2V5LFxuICAgICAgcGFja2FnZV9pZDogZmlyc3RUYXNrLnBhY2thZ2VfaWQsXG4gICAgICBwYWNrYWdlX25hbWU6IGZpcnN0VGFzay5wYWNrYWdlX25hbWUsXG4gICAgICBkaXN0cmljdDogZmlyc3RUYXNrLmRpc3RyaWN0LFxuICAgICAgc2l0ZV9pZDogZmlyc3RUYXNrLnNpdGVfaWQsXG4gICAgICBzaXRlX25hbWU6IGZpcnN0VGFzay5zaXRlX25hbWUsXG4gICAgICB0YXNrczogc2l0ZVRhc2tzLFxuICAgICAgdG90YWxUYXNrczogc2l0ZVRhc2tzLmxlbmd0aCxcbiAgICAgIGNvbXBsZXRlZFRhc2tzLFxuICAgICAgaW5Qcm9ncmVzc1Rhc2tzLFxuICAgICAgbm90U3RhcnRlZFRhc2tzLFxuICAgICAgZGVsYXllZFRhc2tzLFxuICAgICAgd2VpZ2h0ZWRQcm9ncmVzcyxcbiAgICAgIHJpc2tTY29yZSxcbiAgICAgIHJpc2tMZXZlbCxcbiAgICAgIG1heFBsYW5uZWRGaW5pc2gsXG4gICAgICBtYXhMYXN0VXBkYXRlZCxcbiAgICAgIGNvdmVyUGhvdG9EaXJlY3RVcmwsXG4gICAgICBwaG90b0ZvbGRlclVybCxcbiAgICAgIGNvdmVyUGhvdG9TaGFyZVVybCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaXRlcztcbn1cblxuLyoqXG4gKiBDb21wdXRlIG92ZXJhbGwgS1BJc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUtQSXModGFza3M6IFRhc2tXaXRoU3RhdHVzW10pOiBEYXNoYm9hcmRLUElzIHtcbiAgY29uc3QgdW5pcXVlU2l0ZXMgPSBuZXcgU2V0KHRhc2tzLm1hcCh0ID0+IHQuc2l0ZUtleSkpO1xuXG4gIC8vIFNpdGUtbGV2ZWwgYWdncmVnYXRlcyBmb3Igc2l0ZSBLUElzXG4gIGNvbnN0IHNpdGVTdGF0dXMgPSBuZXcgTWFwPHN0cmluZywgeyB0b3RhbDogbnVtYmVyOyBjb21wbGV0ZWQ6IG51bWJlciB9PigpO1xuICB0YXNrcy5mb3JFYWNoKHQgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gc2l0ZVN0YXR1cy5nZXQodC5zaXRlS2V5KSB8fCB7IHRvdGFsOiAwLCBjb21wbGV0ZWQ6IDAgfTtcbiAgICBlbnRyeS50b3RhbCArPSAxO1xuICAgIGlmICh0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIGVudHJ5LmNvbXBsZXRlZCArPSAxO1xuICAgIHNpdGVTdGF0dXMuc2V0KHQuc2l0ZUtleSwgZW50cnkpO1xuICB9KTtcblxuICAvLyBXZWlnaHRlZCBwcm9ncmVzcyAoc2FtZSBmaXggYXMgc2l0ZSBwcm9ncmVzcylcbiAgbGV0IHRvdGFsV2VpZ2h0ZWRQcm9ncmVzcyA9IDA7XG4gIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgLy8gQ1JJVElDQUwgRklYOiBUcmVhdCBudWxsIHByb2dyZXNzIGFzIDAsIE5PVCBleGNsdWRlXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSB0YXNrLnByb2dyZXNzX3BjdCA/PyAwO1xuICAgIGNvbnN0IHdlaWdodCA9IHRhc2sud2VpZ2h0IHx8IDE7XG5cbiAgICB0b3RhbFdlaWdodGVkUHJvZ3Jlc3MgKz0gcHJvZ3Jlc3MgKiB3ZWlnaHQ7XG4gICAgdG90YWxXZWlnaHQgKz0gdGFzay53ZWlnaHQ7XG4gIH1cblxuICBsZXQgb3ZlcmFsbFdlaWdodGVkUHJvZ3Jlc3MgPSB0b3RhbFdlaWdodCA+IDAgPyB0b3RhbFdlaWdodGVkUHJvZ3Jlc3MgLyB0b3RhbFdlaWdodCA6IDA7XG4gIG92ZXJhbGxXZWlnaHRlZFByb2dyZXNzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBvdmVyYWxsV2VpZ2h0ZWRQcm9ncmVzcykpO1xuXG4gIGNvbnN0IHNpdGVzV2l0aENvbXBsZXRlZCA9IEFycmF5LmZyb20oc2l0ZVN0YXR1cy52YWx1ZXMoKSkuZmlsdGVyKHMgPT4gcy5jb21wbGV0ZWQgPiAwKS5sZW5ndGg7XG4gIGNvbnN0IHNpdGVzRnVsbHlDb21wbGV0ZWQgPSBBcnJheS5mcm9tKHNpdGVTdGF0dXMudmFsdWVzKCkpLmZpbHRlcihzID0+IHMuY29tcGxldGVkID09PSBzLnRvdGFsICYmIHMudG90YWwgPiAwKS5sZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFNpdGVzOiB1bmlxdWVTaXRlcy5zaXplLFxuICAgIHRvdGFsVGFza3M6IHRhc2tzLmxlbmd0aCxcbiAgICBvdmVyYWxsV2VpZ2h0ZWRQcm9ncmVzcyxcbiAgICBzaXRlc1dpdGhDb21wbGV0ZWQsXG4gICAgc2l0ZXNGdWxseUNvbXBsZXRlZCxcbiAgICBkZWxheWVkVGFza3M6IHRhc2tzLmZpbHRlcih0ID0+IHQuaXNEZWxheWVkKS5sZW5ndGgsXG4gICAgbm90U3RhcnRlZFRhc2tzOiB0YXNrcy5maWx0ZXIodCA9PiB0LnN0YXR1cyA9PT0gJ25vdC1zdGFydGVkJykubGVuZ3RoLFxuICAgIGluUHJvZ3Jlc3NUYXNrczogdGFza3MuZmlsdGVyKHQgPT4gdC5zdGF0dXMgPT09ICdpbi1wcm9ncmVzcycpLmxlbmd0aCxcbiAgICBjb21wbGV0ZWRUYXNrczogdGFza3MuZmlsdGVyKHQgPT4gdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKS5sZW5ndGgsXG4gIH07XG59XG5cbi8qKlxuICogQXBwbHkgZmlsdGVycyB0byB0YXNrc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKHRhc2tzOiBUYXNrV2l0aFN0YXR1c1tdLCBmaWx0ZXJzOiBGaWx0ZXJTdGF0ZSk6IFRhc2tXaXRoU3RhdHVzW10ge1xuICBsZXQgZmlsdGVyZWQgPSB0YXNrcztcblxuICAvLyBQYWNrYWdlIG5hbWVzXG4gIGlmIChmaWx0ZXJzLnBhY2thZ2VOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodCA9PiBmaWx0ZXJzLnBhY2thZ2VOYW1lcy5pbmNsdWRlcyh0LnBhY2thZ2VfbmFtZSkpO1xuICB9XG5cbiAgLy8gRGlzdHJpY3RzXG4gIGlmIChmaWx0ZXJzLmRpc3RyaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodCA9PiBmaWx0ZXJzLmRpc3RyaWN0cy5pbmNsdWRlcyh0LmRpc3RyaWN0KSk7XG4gIH1cblxuICAvLyBTaXRlIG5hbWUgc2VhcmNoXG4gIGlmIChmaWx0ZXJzLnNpdGVOYW1lU2VhcmNoLnRyaW0oKSkge1xuICAgIGNvbnN0IHNlYXJjaCA9IGZpbHRlcnMuc2l0ZU5hbWVTZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcih0ID0+XG4gICAgICB0LnNpdGVfbmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaCkgfHxcbiAgICAgIHQuc2l0ZV9pZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaClcbiAgICApO1xuICB9XG5cbiAgLy8gRGlzY2lwbGluZXNcbiAgaWYgKGZpbHRlcnMuZGlzY2lwbGluZXMubGVuZ3RoID4gMCkge1xuICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHQgPT4gZmlsdGVycy5kaXNjaXBsaW5lcy5pbmNsdWRlcyh0LmRpc2NpcGxpbmUpKTtcbiAgfVxuXG4gIC8vIERlbGF5IGZsYWdzXG4gIGlmIChmaWx0ZXJzLmRlbGF5RmxhZ3MubGVuZ3RoID4gMCkge1xuICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHQgPT5cbiAgICAgIHQuZGVsYXlfZmxhZ19jYWxjICYmIGZpbHRlcnMuZGVsYXlGbGFncy5pbmNsdWRlcyh0LmRlbGF5X2ZsYWdfY2FsYylcbiAgICApO1xuICB9XG5cbiAgLy8gRGF0ZSByYW5nZVxuICBpZiAoZmlsdGVycy5kYXRlUmFuZ2VTdGFydCkge1xuICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHQgPT5cbiAgICAgIHQucGxhbm5lZF9zdGFydCAmJiB0LnBsYW5uZWRfc3RhcnQgPj0gZmlsdGVycy5kYXRlUmFuZ2VTdGFydCFcbiAgICApO1xuICB9XG4gIGlmIChmaWx0ZXJzLmRhdGVSYW5nZUVuZCkge1xuICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHQgPT5cbiAgICAgIHQucGxhbm5lZF9maW5pc2ggJiYgdC5wbGFubmVkX2ZpbmlzaCA8PSBmaWx0ZXJzLmRhdGVSYW5nZUVuZCFcbiAgICApO1xuICB9XG5cbiAgLy8gU2hvdyBvbmx5IGRlbGF5ZWRcbiAgaWYgKGZpbHRlcnMuc2hvd09ubHlEZWxheWVkKSB7XG4gICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodCA9PiB0LmlzRGVsYXllZCk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogR2V0IHVuaXF1ZSB2YWx1ZXMgZm9yIGZpbHRlciBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJPcHRpb25zKHRhc2tzOiBUYXNrV2l0aFN0YXR1c1tdKSB7XG4gIGNvbnN0IHBhY2thZ2VOYW1lcyA9IEFycmF5LmZyb20obmV3IFNldCh0YXNrcy5tYXAodCA9PiB0LnBhY2thZ2VfbmFtZSkpKS5zb3J0KCk7XG4gIGNvbnN0IGRpc3RyaWN0cyA9IEFycmF5LmZyb20obmV3IFNldCh0YXNrcy5tYXAodCA9PiB0LmRpc3RyaWN0KSkpLnNvcnQoKTtcbiAgY29uc3QgZGlzY2lwbGluZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodGFza3MubWFwKHQgPT4gdC5kaXNjaXBsaW5lKSkpLnNvcnQoKTtcbiAgY29uc3QgZGVsYXlGbGFncyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldCh0YXNrcy5tYXAodCA9PiB0LmRlbGF5X2ZsYWdfY2FsYykuZmlsdGVyKChkKTogZCBpcyBzdHJpbmcgPT4gZCAhPT0gbnVsbCkpXG4gICkuc29ydCgpO1xuXG4gIHJldHVybiB7IHBhY2thZ2VOYW1lcywgZGlzdHJpY3RzLCBkaXNjaXBsaW5lcywgZGVsYXlGbGFncyB9O1xufVxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZVNpdGVXZWlnaHRzIiwidGFza3MiLCJzaXRlV2VpZ2h0cyIsIk1hcCIsInRhc2siLCJzaXRlS2V5Iiwic2l0ZV91aWQiLCJjdXJyZW50VG90YWwiLCJnZXQiLCJzZXQiLCJ0YXNrX3dlaWdodF9maW5hbCIsIm1hcCIsInNpdGVUb3RhbCIsInRhc2tfd2VpZ2h0X25vcm1fc2l0ZSIsImdyb3VwVGFza3NCeVNpdGUiLCJzaXRlTWFwIiwiZXhpc3RpbmciLCJwdXNoIiwic2l0ZXMiLCJzaXRlVGFza3MiLCJlbnRyaWVzIiwiZmlyc3RUYXNrIiwidG90YWxXZWlnaHRlZFByb2dyZXNzIiwidG90YWxXZWlnaHQiLCJpc0RlYnVnU2l0ZSIsInNpdGVfbmFtZSIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJwcm9ncmVzcyIsInByb2dyZXNzX3BjdCIsIndlaWdodCIsInRhc2tfbmFtZSIsIndlaWdodGVkUHJvZ3Jlc3MiLCJNYXRoIiwibWF4IiwibWluIiwidG9GaXhlZCIsImNvbXBsZXRlZFRhc2tzIiwiZmlsdGVyIiwidCIsInN0YXR1cyIsImluUHJvZ3Jlc3NUYXNrcyIsIm5vdFN0YXJ0ZWRUYXNrcyIsImRlbGF5ZWRUYXNrcyIsImlzRGVsYXllZCIsInRvdGFsV2VpZ2h0ZWRSaXNrIiwidG90YWxSaXNrV2VpZ2h0Iiwicmlza190YXNrIiwicmlza1Njb3JlIiwicmlza0xldmVsIiwicGxhbm5lZEZpbmlzaGVzIiwicGxhbm5lZF9maW5pc2giLCJkIiwibWF4UGxhbm5lZEZpbmlzaCIsIkRhdGUiLCJnZXRUaW1lIiwibGFzdFVwZGF0ZXMiLCJsYXN0X3VwZGF0ZWQiLCJtYXhMYXN0VXBkYXRlZCIsImNvdmVyUGhvdG9EaXJlY3RVcmwiLCJmaW5kIiwiY292ZXJfcGhvdG9fZGlyZWN0X3VybCIsInBob3RvRm9sZGVyVXJsIiwicGhvdG9fZm9sZGVyX3VybCIsImNvdmVyUGhvdG9TaGFyZVVybCIsImNvdmVyX3Bob3RvX3NoYXJlX3VybCIsInBhY2thZ2VfaWQiLCJwYWNrYWdlX25hbWUiLCJkaXN0cmljdCIsInNpdGVfaWQiLCJ0b3RhbFRhc2tzIiwiY29tcHV0ZUtQSXMiLCJ1bmlxdWVTaXRlcyIsIlNldCIsInNpdGVTdGF0dXMiLCJmb3JFYWNoIiwiZW50cnkiLCJ0b3RhbCIsImNvbXBsZXRlZCIsIm92ZXJhbGxXZWlnaHRlZFByb2dyZXNzIiwic2l0ZXNXaXRoQ29tcGxldGVkIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwicyIsInNpdGVzRnVsbHlDb21wbGV0ZWQiLCJ0b3RhbFNpdGVzIiwic2l6ZSIsImFwcGx5RmlsdGVycyIsImZpbHRlcnMiLCJmaWx0ZXJlZCIsInBhY2thZ2VOYW1lcyIsImluY2x1ZGVzIiwiZGlzdHJpY3RzIiwic2l0ZU5hbWVTZWFyY2giLCJ0cmltIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJkaXNjaXBsaW5lcyIsImRpc2NpcGxpbmUiLCJkZWxheUZsYWdzIiwiZGVsYXlfZmxhZ19jYWxjIiwiZGF0ZVJhbmdlU3RhcnQiLCJwbGFubmVkX3N0YXJ0IiwiZGF0ZVJhbmdlRW5kIiwic2hvd09ubHlEZWxheWVkIiwiZ2V0RmlsdGVyT3B0aW9ucyIsInNvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/lib/dataProcessor.ts\n");

/***/ }),

/***/ "(api)/./src/pages/api/compliance.ts":
/*!*************************************!*\
  !*** ./src/pages/api/compliance.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/backend/cache */ \"(api)/./src/lib/backend/cache.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__]);\n_lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * API Route: GET /api/compliance\n * Returns package-level compliance data for all flood packages\n */ \nasync function handler(req, res) {\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        // Initialize cache if not already done\n        if (!_lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__.dataCache.isInitialized()) {\n            await _lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__.dataCache.initialize();\n        }\n        const data = _lib_backend_cache__WEBPACK_IMPORTED_MODULE_0__.dataCache.getData();\n        const packageCompliance = data.packageCompliance;\n        // Compute summary counts\n        const entries = Object.values(packageCompliance);\n        const summary = {\n            compliant: entries.filter((c)=>c.status === \"COMPLIANT\").length,\n            nonCompliant: entries.filter((c)=>c.status === \"NON_COMPLIANT\").length,\n            unknown: entries.filter((c)=>c.status === \"UNKNOWN\").length,\n            total: entries.length\n        };\n        return res.status(200).json({\n            success: true,\n            packageCompliance,\n            ipcData: data.ipcData,\n            summary,\n            lastRefresh: data.lastRefresh\n        });\n    } catch (error) {\n        console.error(\"Error in /api/compliance:\", error);\n        return res.status(500).json({\n            error: \"Failed to fetch compliance data\",\n            message: error instanceof Error ? error.message : \"Unknown error\"\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zcmMvcGFnZXMvYXBpL2NvbXBsaWFuY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FHK0M7QUFnQmpDLGVBQWVDLFFBQzFCQyxHQUFtQixFQUNuQkMsR0FBOEU7SUFFOUUsSUFBSUQsSUFBSUUsTUFBTSxLQUFLLE9BQU87UUFDdEIsT0FBT0QsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXFCO0lBQzlEO0lBRUEsSUFBSTtRQUNBLHVDQUF1QztRQUN2QyxJQUFJLENBQUNQLHlEQUFTQSxDQUFDUSxhQUFhLElBQUk7WUFDNUIsTUFBTVIseURBQVNBLENBQUNTLFVBQVU7UUFDOUI7UUFFQSxNQUFNQyxPQUFPVix5REFBU0EsQ0FBQ1csT0FBTztRQUM5QixNQUFNQyxvQkFBb0JGLEtBQUtFLGlCQUFpQjtRQUVoRCx5QkFBeUI7UUFDekIsTUFBTUMsVUFBVUMsT0FBT0MsTUFBTSxDQUFDSDtRQUM5QixNQUFNSSxVQUFVO1lBQ1pDLFdBQVdKLFFBQVFLLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWQsTUFBTSxLQUFLLGFBQWFlLE1BQU07WUFDL0RDLGNBQWNSLFFBQVFLLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWQsTUFBTSxLQUFLLGlCQUFpQmUsTUFBTTtZQUN0RUUsU0FBU1QsUUFBUUssTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFZCxNQUFNLEtBQUssV0FBV2UsTUFBTTtZQUMzREcsT0FBT1YsUUFBUU8sTUFBTTtRQUN6QjtRQUVBLE9BQU9qQixJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQ3hCa0IsU0FBUztZQUNUWjtZQUNBYSxTQUFTZixLQUFLZSxPQUFPO1lBQ3JCVDtZQUNBVSxhQUFhaEIsS0FBS2dCLFdBQVc7UUFDakM7SUFDSixFQUFFLE9BQU9uQixPQUFPO1FBQ1pvQixRQUFRcEIsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsT0FBT0osSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUN4QkMsT0FBTztZQUNQcUIsU0FBU3JCLGlCQUFpQnNCLFFBQVF0QixNQUFNcUIsT0FBTyxHQUFHO1FBQ3REO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb29kZGFzaGJvYXJkLy4vc3JjL3BhZ2VzL2FwaS9jb21wbGlhbmNlLnRzP2Q2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgUm91dGU6IEdFVCAvYXBpL2NvbXBsaWFuY2VcbiAqIFJldHVybnMgcGFja2FnZS1sZXZlbCBjb21wbGlhbmNlIGRhdGEgZm9yIGFsbCBmbG9vZCBwYWNrYWdlc1xuICovXG5cbmltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuaW1wb3J0IHsgZGF0YUNhY2hlIH0gZnJvbSAnQC9saWIvYmFja2VuZC9jYWNoZSc7XG5pbXBvcnQgdHlwZSB7IFBhY2thZ2VDb21wbGlhbmNlTWFwLCBJUENEYXRhIH0gZnJvbSAnQC90eXBlcyc7XG5cbmludGVyZmFjZSBDb21wbGlhbmNlUmVzcG9uc2Uge1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgcGFja2FnZUNvbXBsaWFuY2U6IFBhY2thZ2VDb21wbGlhbmNlTWFwO1xuICAgIGlwY0RhdGE6IElQQ0RhdGE7XG4gICAgc3VtbWFyeToge1xuICAgICAgICBjb21wbGlhbnQ6IG51bWJlcjtcbiAgICAgICAgbm9uQ29tcGxpYW50OiBudW1iZXI7XG4gICAgICAgIHVua25vd246IG51bWJlcjtcbiAgICAgICAgdG90YWw6IG51bWJlcjtcbiAgICB9O1xuICAgIGxhc3RSZWZyZXNoOiBEYXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICAgIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gICAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8Q29tcGxpYW5jZVJlc3BvbnNlIHwgeyBlcnJvcjogc3RyaW5nOyBtZXNzYWdlPzogc3RyaW5nIH0+XG4pIHtcbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2FjaGUgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgICAgICBpZiAoIWRhdGFDYWNoZS5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IGRhdGFDYWNoZS5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gZGF0YUNhY2hlLmdldERhdGEoKTtcbiAgICAgICAgY29uc3QgcGFja2FnZUNvbXBsaWFuY2UgPSBkYXRhLnBhY2thZ2VDb21wbGlhbmNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgc3VtbWFyeSBjb3VudHNcbiAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC52YWx1ZXMocGFja2FnZUNvbXBsaWFuY2UpO1xuICAgICAgICBjb25zdCBzdW1tYXJ5ID0ge1xuICAgICAgICAgICAgY29tcGxpYW50OiBlbnRyaWVzLmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnQ09NUExJQU5UJykubGVuZ3RoLFxuICAgICAgICAgICAgbm9uQ29tcGxpYW50OiBlbnRyaWVzLmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnTk9OX0NPTVBMSUFOVCcpLmxlbmd0aCxcbiAgICAgICAgICAgIHVua25vd246IGVudHJpZXMuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdVTktOT1dOJykubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWw6IGVudHJpZXMubGVuZ3RoLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgcGFja2FnZUNvbXBsaWFuY2UsXG4gICAgICAgICAgICBpcGNEYXRhOiBkYXRhLmlwY0RhdGEsXG4gICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgbGFzdFJlZnJlc2g6IGRhdGEubGFzdFJlZnJlc2gsXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIC9hcGkvY29tcGxpYW5jZTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBjb21wbGlhbmNlIGRhdGEnLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJkYXRhQ2FjaGUiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwiaXNJbml0aWFsaXplZCIsImluaXRpYWxpemUiLCJkYXRhIiwiZ2V0RGF0YSIsInBhY2thZ2VDb21wbGlhbmNlIiwiZW50cmllcyIsIk9iamVjdCIsInZhbHVlcyIsInN1bW1hcnkiLCJjb21wbGlhbnQiLCJmaWx0ZXIiLCJjIiwibGVuZ3RoIiwibm9uQ29tcGxpYW50IiwidW5rbm93biIsInRvdGFsIiwic3VjY2VzcyIsImlwY0RhdGEiLCJsYXN0UmVmcmVzaCIsImNvbnNvbGUiLCJtZXNzYWdlIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/compliance.ts\n");

/***/ }),

/***/ "(api)/./src/types/index.ts":
/*!****************************!*\
  !*** ./src/types/index.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   taskSchema: () => (/* binding */ taskSchema)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"zod\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([zod__WEBPACK_IMPORTED_MODULE_0__]);\nzod__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n// Raw task schema from Excel\nconst taskSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    package_id: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_0__.z.number()\n    ]).transform((val)=>String(val)),\n    package_name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    district: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    site_id: zod__WEBPACK_IMPORTED_MODULE_0__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_0__.z.number()\n    ]).transform(String),\n    site_name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    discipline: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    task_name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    planned_start: zod__WEBPACK_IMPORTED_MODULE_0__.z.date().nullable(),\n    planned_finish: zod__WEBPACK_IMPORTED_MODULE_0__.z.date().nullable(),\n    planned_duration_days: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),\n    actual_start: zod__WEBPACK_IMPORTED_MODULE_0__.z.date().nullable(),\n    actual_finish: zod__WEBPACK_IMPORTED_MODULE_0__.z.date().nullable(),\n    progress_pct: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().min(0).max(100).nullable(),\n    Variance: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().nullable(),\n    delay_flag_calc: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),\n    last_updated: zod__WEBPACK_IMPORTED_MODULE_0__.z.date().nullable(),\n    remarks: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),\n    // Photo fields - allow empty strings and transform to null\n    photo_folder_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    cover_photo_share_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    cover_photo_direct_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    // Optional fields for before/after photos\n    before_photo_share_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    before_photo_direct_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    after_photo_share_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional(),\n    after_photo_direct_url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().transform((val)=>val === \"\" ? null : val).nullable().optional()\n});\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbi8vIERhdGUgdHJpcGxlOiBzdG9yZXMgcmF3LCBJU08sIGFuZCBlcG9jaCBmb3JtYXRzXG5leHBvcnQgaW50ZXJmYWNlIERhdGVUcmlwbGUge1xuICByYXc6IHN0cmluZztcbiAgaXNvOiBzdHJpbmc7XG4gIGVwb2NoOiBudW1iZXI7XG59XG5cbi8vIFRhc2sgc3RhdHVzICg1IHN0YXRlcylcbmV4cG9ydCB0eXBlIFRhc2tTdGF0dXMgPSAnY29tcGxldGVkJyB8ICdpbi1wcm9ncmVzcycgfCAnbm90LXN0YXJ0ZWQnIHwgJ292ZXJkdWUnIHwgJ3N0YWxsZWQnO1xuXG4vLyBTY2hlZHVsZSBidWNrZXRcbmV4cG9ydCB0eXBlIFNjaGVkdWxlQnVja2V0ID0gJ2FoZWFkJyB8ICdvbi10cmFjaycgfCAnYXQtcmlzaycgfCAnZGVsYXllZCc7XG5cbi8vIEV2aWRlbmNlIHN0YXR1c1xuZXhwb3J0IHR5cGUgRXZpZGVuY2VTdGF0dXMgPSAnbm9uZScgfCAnYmVmb3JlLW9ubHknIHwgJ2FmdGVyLW9ubHknIHwgJ2JlZm9yZS1hZnRlcic7XG5cbi8vIFBob3RvIHJlc29sdXRpb24gc3RhdHVzXG5leHBvcnQgdHlwZSBQaG90b1N0YXR1cyA9ICdkaXJlY3Qtb2snIHwgJ3Jlc29sdmVkLWZyb20tc2hhcmUnIHwgJ3VucmVzb2x2YWJsZScgfCAnbWlzc2luZyc7XG5cbi8vIERhdGEgcXVhbGl0eSBmbGFnXG5leHBvcnQgdHlwZSBRdWFsaXR5RmxhZyA9ICdjcml0aWNhbCcgfCAnd2FybmluZycgfCAnaW5mbycgfCBudWxsO1xuXG4vLyBSYXcgdGFzayBzY2hlbWEgZnJvbSBFeGNlbFxuZXhwb3J0IGNvbnN0IHRhc2tTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHBhY2thZ2VfaWQ6IHoudW5pb24oW3ouc3RyaW5nKCksIHoubnVtYmVyKCldKS50cmFuc2Zvcm0odmFsID0+IFN0cmluZyh2YWwpKSxcbiAgcGFja2FnZV9uYW1lOiB6LnN0cmluZygpLFxuICBkaXN0cmljdDogei5zdHJpbmcoKSxcbiAgc2l0ZV9pZDogei51bmlvbihbei5zdHJpbmcoKSwgei5udW1iZXIoKV0pLnRyYW5zZm9ybShTdHJpbmcpLFxuICBzaXRlX25hbWU6IHouc3RyaW5nKCksXG4gIGRpc2NpcGxpbmU6IHouc3RyaW5nKCksXG4gIHRhc2tfbmFtZTogei5zdHJpbmcoKSxcbiAgcGxhbm5lZF9zdGFydDogei5kYXRlKCkubnVsbGFibGUoKSxcbiAgcGxhbm5lZF9maW5pc2g6IHouZGF0ZSgpLm51bGxhYmxlKCksXG4gIHBsYW5uZWRfZHVyYXRpb25fZGF5czogei5udW1iZXIoKS5udWxsYWJsZSgpLFxuICBhY3R1YWxfc3RhcnQ6IHouZGF0ZSgpLm51bGxhYmxlKCksXG4gIGFjdHVhbF9maW5pc2g6IHouZGF0ZSgpLm51bGxhYmxlKCksXG4gIHByb2dyZXNzX3BjdDogei5udW1iZXIoKS5taW4oMCkubWF4KDEwMCkubnVsbGFibGUoKSxcbiAgVmFyaWFuY2U6IHoubnVtYmVyKCkubnVsbGFibGUoKSxcbiAgZGVsYXlfZmxhZ19jYWxjOiB6LnN0cmluZygpLm51bGxhYmxlKCksXG4gIGxhc3RfdXBkYXRlZDogei5kYXRlKCkubnVsbGFibGUoKSxcbiAgcmVtYXJrczogei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICAvLyBQaG90byBmaWVsZHMgLSBhbGxvdyBlbXB0eSBzdHJpbmdzIGFuZCB0cmFuc2Zvcm0gdG8gbnVsbFxuICBwaG90b19mb2xkZXJfdXJsOiB6LnN0cmluZygpLnRyYW5zZm9ybSh2YWwgPT4gdmFsID09PSAnJyA/IG51bGwgOiB2YWwpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgY292ZXJfcGhvdG9fc2hhcmVfdXJsOiB6LnN0cmluZygpLnRyYW5zZm9ybSh2YWwgPT4gdmFsID09PSAnJyA/IG51bGwgOiB2YWwpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgY292ZXJfcGhvdG9fZGlyZWN0X3VybDogei5zdHJpbmcoKS50cmFuc2Zvcm0odmFsID0+IHZhbCA9PT0gJycgPyBudWxsIDogdmFsKS5udWxsYWJsZSgpLm9wdGlvbmFsKCksXG4gIC8vIE9wdGlvbmFsIGZpZWxkcyBmb3IgYmVmb3JlL2FmdGVyIHBob3Rvc1xuICBiZWZvcmVfcGhvdG9fc2hhcmVfdXJsOiB6LnN0cmluZygpLnRyYW5zZm9ybSh2YWwgPT4gdmFsID09PSAnJyA/IG51bGwgOiB2YWwpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgYmVmb3JlX3Bob3RvX2RpcmVjdF91cmw6IHouc3RyaW5nKCkudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09ICcnID8gbnVsbCA6IHZhbCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICBhZnRlcl9waG90b19zaGFyZV91cmw6IHouc3RyaW5nKCkudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09ICcnID8gbnVsbCA6IHZhbCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICBhZnRlcl9waG90b19kaXJlY3RfdXJsOiB6LnN0cmluZygpLnRyYW5zZm9ybSh2YWwgPT4gdmFsID09PSAnJyA/IG51bGwgOiB2YWwpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbn0pO1xuXG5leHBvcnQgdHlwZSBUYXNrID0gei5pbmZlcjx0eXBlb2YgdGFza1NjaGVtYT47XG5cbi8vIEVuaGFuY2VkIHRhc2sgd2l0aCBhbGwgY29tcHV0ZWQgZmllbGRzXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tXaXRoU3RhdHVzIGV4dGVuZHMgVGFzayB7XG4gIC8vIEtleXNcbiAgc2l0ZV91aWQ6IHN0cmluZztcbiAgdGFza191aWQ6IHN0cmluZztcbiAgc2l0ZUtleTogc3RyaW5nOyAvLyBLZWVwIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgLy8gU3RhdHVzIGZpZWxkc1xuICBzdGF0dXM6IFRhc2tTdGF0dXM7XG4gIGlzX2NvbXBsZXRlZDogYm9vbGVhbjtcbiAgaXNfb3ZlcmR1ZTogYm9vbGVhbjtcbiAgaXNfc3RhbGxlZDogYm9vbGVhbjtcbiAgaXNEZWxheWVkOiBib29sZWFuOyAvLyBLZWVwIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgLy8gU2NoZWR1bGUgaW50ZWxsaWdlbmNlXG4gIHBsYW5uZWRfcHJvZ3Jlc3NfcGN0OiBudW1iZXIgfCBudWxsO1xuICBwcm9ncmVzc19kZWx0YV9wY3Q6IG51bWJlciB8IG51bGw7XG4gIHNjaGVkdWxlX2J1Y2tldDogU2NoZWR1bGVCdWNrZXQgfCBudWxsO1xuICBzbGlwX2RheXM6IG51bWJlcjtcbiAgc3RhbGVfdXBkYXRlX2ZsYWc6IGJvb2xlYW47XG5cbiAgLy8gV2VpZ2h0c1xuICB3ZWlnaHQ6IG51bWJlcjsgLy8gS2VlcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICB0YXNrX3dlaWdodF9kYXlzOiBudW1iZXI7XG4gIHRhc2tfd2VpZ2h0X2ZpbmFsOiBudW1iZXI7XG4gIHRhc2tfd2VpZ2h0X25vcm1fc2l0ZTogbnVtYmVyO1xuXG4gIC8vIFBob3RvIHJlc29sdXRpb25cbiAgYmVmb3JlX3VybF9yZXNvbHZlZDogc3RyaW5nIHwgbnVsbDtcbiAgYWZ0ZXJfdXJsX3Jlc29sdmVkOiBzdHJpbmcgfCBudWxsO1xuICBiZWZvcmVfcGhvdG9fc3RhdHVzOiBQaG90b1N0YXR1cztcbiAgYWZ0ZXJfcGhvdG9fc3RhdHVzOiBQaG90b1N0YXR1cztcbiAgZXZpZGVuY2Vfc3RhdHVzOiBFdmlkZW5jZVN0YXR1cztcbiAgZXZpZGVuY2VfY29tcGxpYW50X2ZsYWc6IGJvb2xlYW47XG5cbiAgLy8gRGF0YSBxdWFsaXR5XG4gIGRhdGFfcXVhbGl0eV9pc3N1ZXM6IHN0cmluZ1tdO1xuICBkYXRhX3F1YWxpdHlfZmxhZzogUXVhbGl0eUZsYWc7XG5cbiAgLy8gUmlza1xuICByaXNrX3Rhc2s6IG51bWJlcjtcblxuICAvLyBUb2RheSByZWZlcmVuY2UgKGZvciBjYWxjdWxhdGlvbnMpXG4gIHRvZGF5X2Vwb2NoOiBudW1iZXI7XG59XG5cbi8vIFNpdGUgYWdncmVnYXRlXG5leHBvcnQgaW50ZXJmYWNlIFNpdGVBZ2dyZWdhdGUge1xuICBzaXRlS2V5OiBzdHJpbmc7XG4gIHBhY2thZ2VfaWQ6IHN0cmluZztcbiAgcGFja2FnZV9uYW1lOiBzdHJpbmc7XG4gIGRpc3RyaWN0OiBzdHJpbmc7XG4gIHNpdGVfaWQ6IHN0cmluZztcbiAgc2l0ZV9uYW1lOiBzdHJpbmc7XG4gIHRhc2tzOiBUYXNrV2l0aFN0YXR1c1tdO1xuICB0b3RhbFRhc2tzOiBudW1iZXI7XG4gIGNvbXBsZXRlZFRhc2tzOiBudW1iZXI7XG4gIGluUHJvZ3Jlc3NUYXNrczogbnVtYmVyO1xuICBub3RTdGFydGVkVGFza3M6IG51bWJlcjtcbiAgZGVsYXllZFRhc2tzOiBudW1iZXI7XG4gIHdlaWdodGVkUHJvZ3Jlc3M6IG51bWJlcjtcbiAgcmlza1Njb3JlOiBudW1iZXI7XG4gIHJpc2tMZXZlbDogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JztcbiAgbWF4UGxhbm5lZEZpbmlzaDogRGF0ZSB8IG51bGw7XG4gIG1heExhc3RVcGRhdGVkOiBEYXRlIHwgbnVsbDtcbiAgY292ZXJQaG90b0RpcmVjdFVybDogc3RyaW5nIHwgbnVsbDtcbiAgcGhvdG9Gb2xkZXJVcmw6IHN0cmluZyB8IG51bGw7XG4gIGNvdmVyUGhvdG9TaGFyZVVybDogc3RyaW5nIHwgbnVsbDtcbn1cblxuLy8gT3ZlcmFsbCBLUElzXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZEtQSXMge1xuICB0b3RhbFNpdGVzOiBudW1iZXI7XG4gIHRvdGFsVGFza3M6IG51bWJlcjtcbiAgb3ZlcmFsbFdlaWdodGVkUHJvZ3Jlc3M6IG51bWJlcjtcbiAgc2l0ZXNXaXRoQ29tcGxldGVkOiBudW1iZXI7XG4gIHNpdGVzRnVsbHlDb21wbGV0ZWQ6IG51bWJlcjtcbiAgZGVsYXllZFRhc2tzOiBudW1iZXI7XG4gIG5vdFN0YXJ0ZWRUYXNrczogbnVtYmVyO1xuICBpblByb2dyZXNzVGFza3M6IG51bWJlcjtcbiAgY29tcGxldGVkVGFza3M6IG51bWJlcjtcbn1cblxuLy8gRmlsdGVyIHN0YXRlXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlclN0YXRlIHtcbiAgcGFja2FnZU5hbWVzOiBzdHJpbmdbXTtcbiAgZGlzdHJpY3RzOiBzdHJpbmdbXTtcbiAgc2l0ZU5hbWVTZWFyY2g6IHN0cmluZztcbiAgZGlzY2lwbGluZXM6IHN0cmluZ1tdO1xuICBkZWxheUZsYWdzOiBzdHJpbmdbXTtcbiAgZGF0ZVJhbmdlU3RhcnQ6IERhdGUgfCBudWxsO1xuICBkYXRlUmFuZ2VFbmQ6IERhdGUgfCBudWxsO1xuICBzaG93T25seURlbGF5ZWQ6IGJvb2xlYW47XG59XG5cbi8vIFBhY2thZ2UtbGV2ZWwgY29tcGxpYW5jZSBzdGF0dXNcbmV4cG9ydCB0eXBlIENvbXBsaWFuY2VTdGF0dXMgPSAnQ09NUExJQU5UJyB8ICdOT05fQ09NUExJQU5UJyB8ICdVTktOT1dOJztcblxuLy8gUGFja2FnZSBjb21wbGlhbmNlIGRhdGEgKHJlYWQgZnJvbSBWMjpYMiBpbiBlYWNoIHNoZWV0KVxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlQ29tcGxpYW5jZSB7XG4gIG5vX29mX3N0YWZmX3JmYjogJ1llcycgfCAnTm8nIHwgbnVsbDtcbiAgY2VzbXBzX3N1Ym1pdHRlZDogJ1llcycgfCAnTm8nIHwgbnVsbDtcbiAgb2hzX21lYXN1cmVzOiAnWWVzJyB8ICdObycgfCBudWxsO1xuICBzdGF0dXM6IENvbXBsaWFuY2VTdGF0dXM7XG4gIGlzc3Vlczogc3RyaW5nW107XG59XG5cbi8vIE1hcCBvZiBwYWNrYWdlX2lkIC0+IGNvbXBsaWFuY2VcbmV4cG9ydCB0eXBlIFBhY2thZ2VDb21wbGlhbmNlTWFwID0gUmVjb3JkPHN0cmluZywgUGFja2FnZUNvbXBsaWFuY2U+O1xuXG4vLyBJUEMgKEludGVyaW0gUGF5bWVudCBDZXJ0aWZpY2F0ZSkgZGF0YSB0eXBlc1xuZXhwb3J0IHR5cGUgSVBDU3RhdHVzID0gJ25vdCBzdWJtaXR0ZWQnIHwgJ3N1Ym1pdHRlZCcgfCAnaW4gcHJvY2VzcycgfCAncmVsZWFzZWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElQQ1JlY29yZCB7XG4gIGlwY051bWJlcjogc3RyaW5nOyAvLyBcIklQQyAxXCIsIFwiSVBDIDJcIiwgZXRjLlxuICBzdGF0dXM6IElQQ1N0YXR1cyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBDRGF0YSB7XG4gIHJlY29yZHM6IElQQ1JlY29yZFtdO1xufVxuIl0sIm5hbWVzIjpbInoiLCJ0YXNrU2NoZW1hIiwib2JqZWN0IiwicGFja2FnZV9pZCIsInVuaW9uIiwic3RyaW5nIiwibnVtYmVyIiwidHJhbnNmb3JtIiwidmFsIiwiU3RyaW5nIiwicGFja2FnZV9uYW1lIiwiZGlzdHJpY3QiLCJzaXRlX2lkIiwic2l0ZV9uYW1lIiwiZGlzY2lwbGluZSIsInRhc2tfbmFtZSIsInBsYW5uZWRfc3RhcnQiLCJkYXRlIiwibnVsbGFibGUiLCJwbGFubmVkX2ZpbmlzaCIsInBsYW5uZWRfZHVyYXRpb25fZGF5cyIsImFjdHVhbF9zdGFydCIsImFjdHVhbF9maW5pc2giLCJwcm9ncmVzc19wY3QiLCJtaW4iLCJtYXgiLCJWYXJpYW5jZSIsImRlbGF5X2ZsYWdfY2FsYyIsImxhc3RfdXBkYXRlZCIsInJlbWFya3MiLCJwaG90b19mb2xkZXJfdXJsIiwib3B0aW9uYWwiLCJjb3Zlcl9waG90b19zaGFyZV91cmwiLCJjb3Zlcl9waG90b19kaXJlY3RfdXJsIiwiYmVmb3JlX3Bob3RvX3NoYXJlX3VybCIsImJlZm9yZV9waG90b19kaXJlY3RfdXJsIiwiYWZ0ZXJfcGhvdG9fc2hhcmVfdXJsIiwiYWZ0ZXJfcGhvdG9fZGlyZWN0X3VybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/types/index.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcompliance&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fcompliance.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();